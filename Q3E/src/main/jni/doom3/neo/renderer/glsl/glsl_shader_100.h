
// Unuse C++11 raw string literals for Traditional C++98

#define _PBR_GENERAL_FUNCTION \
"float dot2_4(vec2 a, vec4 b) {\n" \
"    return dot(vec4(a, 0.0, 0.0), b);\n" \
"}\n" \
"\n" \
"vec2 CenterScale( vec2 inTC, vec2 centerScale ) {\n" \
"    float scaleX = centerScale.x;\n" \
"    float scaleY = centerScale.y;\n" \
"    vec4 tc0 = vec4( scaleX, 0.0, 0.0, 0.5 - ( 0.5 * scaleX ) );\n" \
"    vec4 tc1 = vec4( 0.0, scaleY, 0.0, 0.5 - ( 0.5 * scaleY ) );\n" \
"    vec2 finalTC;\n" \
"    finalTC.x = dot2_4( inTC, tc0 );\n" \
"    finalTC.y = dot2_4( inTC, tc1 );\n" \
"    return finalTC;\n" \
"}\n" \
"\n" \
"vec2 Rotate2D( vec2 inTC, vec2 cs ) {\n" \
"    float sinValue = cs.y;\n" \
"    float cosValue = cs.x;\n" \
"\n" \
"    vec4 tc0 = vec4( cosValue, -sinValue, 0.0, ( -0.5 * cosValue ) + ( 0.5 * sinValue ) + 0.5 );\n" \
"    vec4 tc1 = vec4( sinValue, cosValue, 0.0, ( -0.5 * sinValue ) + ( -0.5 * cosValue ) + 0.5 );\n" \
"    vec2 finalTC;\n" \
"    finalTC.x = dot2_4( inTC, tc0 );\n" \
"    finalTC.y = dot2_4( inTC, tc1 );\n" \
"    return finalTC;\n" \
"}\n" \
"\n" \
"// better noise function available at https://github.com/ashima/webgl-noise\n" \
"float rand( vec2 co ) {\n" \
"    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n" \
"}\n" \
"\n" \
"float DistributionGGX(vec3 N, vec3 H, float roughness)\n" \
"{\n" \
"    float a      = roughness*roughness;\n" \
"    float a2     = a*a;\n" \
"    float NdotH  = max(dot(N, H), 0.0);\n" \
"    float NdotH2 = NdotH*NdotH;\n" \
"    float PI = 3.14159265359;\n" \
"    float num   = a2;\n" \
"    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n" \
"    denom = PI * denom * denom;\n" \
"    return num / denom;\n" \
"}\n" \
"\n" \
"float GeometrySchlickGGX(float NdotV, float roughness)\n" \
"{\n" \
"    float r = (roughness + 1.0);\n" \
"    float k = (r*r) / 8.0;\n" \
"    float num   = NdotV;\n" \
"    float denom = NdotV * (1.0 - k) + k;\n" \
"    return num / denom;\n" \
"}\n" \
"float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n" \
"{\n" \
"    float NdotV = max(dot(N, V), 0.0);\n" \
"    float NdotL = max(dot(N, L), 0.0);\n" \
"    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n" \
"    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n" \
"    return ggx1 * ggx2;\n" \
"}\n" \
"\n" \
"vec3 fresnelSchlick(float cosTheta, vec3 F0)\n" \
"{\n" \
"    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n" \
"}\n" \
"\n"

// diffuse map
GLSL_SHADER const char DEFAULT_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute lowp vec4 attr_Color;\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char DEFAULT_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_FragColor = texture2D(u_fragmentMap0, var_TexDiffuse) * u_glColor * var_Color;\n"
"}\n"
;

// shadow
GLSL_SHADER const char SHADOW_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform lowp vec4 u_glColor;\n"
"uniform vec4 u_lightOrigin;\n"
"\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * (attr_Vertex.w * u_lightOrigin + attr_Vertex - u_lightOrigin);\n"
"\n"
"    var_Color = u_glColor;\n"
"}\n"
;
GLSL_SHADER const char SHADOW_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision lowp float;\n"
"\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_FragColor = var_Color;\n"
"}\n"
;
// HeatHaze
GLSL_SHADER const char HEATHAZE_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp mat4 u_modelViewMatrix;\n"
"uniform highp mat4 u_projectionMatrix;\n"
"\n"
"uniform highp vec4 u_vertexParm0; // texture scrolling\n"
"uniform highp vec4 u_vertexParm1; // magnitude of the distortion\n"
"\n"
"varying highp vec4 var_TexCoord1;\n"
"varying highp vec4 var_TexCoord2;\n"
"\n"
"// # input:\n"
"// #\n"
"// # texcoord[0] TEX0 texcoords\n"
"// #\n"
"// # local[0] scroll\n"
"// # local[1] deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
"// #\n"
"// # output:\n"
"// #\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"// #\n"
"// # texCoord[1] is the model surface texture coords with a scroll\n"
"// # texCoord[2] is the copied deform magnitude\n"
"void main(void)\n"
"{\n"
#if HEATHAZE_BFG // BFG
"    // texture 0 takes the texture coordinates and adds a scroll\n"
"    vec4 textureScroll = u_vertexParm0;\n"
"    var_TexCoord1 = vec4( attr_TexCoord.xy, 0.0, 0.0 ) + textureScroll;\n"
"    // texture 1 takes the deform magnitude and scales it by the projection distance\n"
"    vec4 vec = vec4( 0.0, 1.0, 0.0, 1.0 );\n"
"    vec.z  = dot( attr_Vertex, u_modelViewMatrix[2] );\n"
"    // magicProjectionAdjust is a magic scalar that scales the projection since we changed from \n"
"    // using the X axis to the Y axis to calculate R1.  It is an approximation to closely match \n"
"    // what the original game did\n"
"    const float magicProjectionAdjust = 0.43;\n"
"    float x = dot ( vec, u_projectionMatrix[1] ) * magicProjectionAdjust;\n"
"    float w = dot ( vec, u_projectionMatrix[3] );\n"
"    // don't let the recip get near zero for polygons that cross the view plane\n"
"    w = max( w, 1.0 );\n"
"    x /= w;\n"
"    // clamp the distance so the the deformations don't get too wacky near the view\n"
"    x = min( x, 0.02 );\n"
"    vec4 deformMagnitude = u_vertexParm1;\n"
"    var_TexCoord2 = vec4(x) * deformMagnitude;\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"

#else // 2004

"    vec4 R0, R1, R2; // TEMP R0, R1, R2;\n"
"\n"
"    // # texture 1 takes the texture coordinates and adds a scroll\n"
"    var_TexCoord1 = (attr_TexCoord) + (u_vertexParm0); // ADD  result.texcoord[1], vertex.texcoord[0], program.local[0];\n"
"\n"
"    // # texture 2 takes the deform magnitude and scales it by the projection distance\n"
"    vec4 vec = vec4(1.0, 0.0, 0.0, 1.0); // PARAM vec = { 1, 0, 0, 1 };\n"
"\n"
"    R0 = vec; // MOV  R0, vec;\n"
"    R0.z = dot(attr_Vertex, (u_modelViewMatrix)[2]); // DP4  R0.z, vertex.position, state.matrix.modelview.row[2];\n"
"\n"
"    R1 = vec4(dot(R0, (u_projectionMatrix)[0])); // DP4  R1, R0, state.matrix.projection.row[0];\n"
"    R2 = vec4(dot(R0, (u_projectionMatrix)[3])); // DP4  R2, R0, state.matrix.projection.row[3];\n"
"\n"
"    // # don't let the recip get near zero for polygons that cross the view plane\n"
"    R2 = max(R2, vec4(1.0)); // MAX  R2, R2, 1;\n"
"\n"
"    R2 = vec4(1.0 / R2.w); // RCP  R2, R2.w;\n"
"    R1 = (R1) * (R2); // MUL  R1, R1, R2;\n"
"\n"
"    // # clamp the distance so the the deformations don't get too wacky near the view\n"
"    R1 = min(R1, vec4(0.02)); // MIN  R1, R1, 0.02;\n"
"\n"
"    var_TexCoord2 = (R1) * (u_vertexParm1); // MUL  result.texcoord[2], R1, program.local[1];\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
#endif
"}\n"
;
GLSL_SHADER const char HEATHAZE_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap1;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_windowCoords;\n"
"varying highp vec4 var_TexCoord1;\n"
"varying highp vec4 var_TexCoord2;\n"
"\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"// #\n"
"// # env[0] is the 1.0 to _currentRender conversion\n"
"// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"void main(void)\n"
"{\n"
#if HEATHAZE_BFG // BFG
"    // load the filtered normal map and convert to -1 to 1 range\n"
"    vec4 bumpMap = ( texture2D( u_fragmentMap1, var_TexCoord1.xy ) * 2.0 ) - 1.0;\n"
"    vec2 localNormal = bumpMap.wy;\n"
"    // calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    vec2 screenTexCoord = (gl_FragCoord.xy ) * u_windowCoords.xy;\n"
"    screenTexCoord += ( localNormal * var_TexCoord2.xy );\n"
"    screenTexCoord = clamp( screenTexCoord, vec2(0.0), vec2(1.0) );\n"
"    screenTexCoord = screenTexCoord * u_nonPowerOfTwo.xy;\n"
"    gl_FragColor = texture2D( u_fragmentMap0, screenTexCoord );\n"

#else // 2004

"    vec4 localNormal, R0; // TEMP localNormal, R0;\n"
"\n"
"    vec4 subOne = vec4(-1.0, -1.0, -1.0, -1.0); // PARAM subOne = { -1, -1, -1, -1 };\n"
"    vec4 scaleTwo = vec4(2.0, 2.0, 2.0, 2.0); // PARAM scaleTwo = { 2, 2, 2, 2 };\n"
"\n"
"    //# load the filtered normal map and convert to -1 to 1 range\n"
"    localNormal = texture2D(u_fragmentMap1, var_TexCoord1.xy); // TEX  localNormal, fragment.texcoord[1], texture[1], 2D;\n"
"    localNormal.x = localNormal.a; // MOV  localNormal.x, localNormal.a;\n"
"    localNormal = (localNormal) * (scaleTwo) + (subOne); // MAD  localNormal, localNormal, scaleTwo, subOne;\n"
"    //localNormal.z = sqrt(max(0.0, 1.0-localNormal.x*localNormal.x-localNormal.y*localNormal.y));\n"
"\n"
"    // # calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    R0 = (gl_FragCoord) * (u_windowCoords); // MUL  R0, fragment.position, program.env[1];\n"
"\n"
"    //localNormal.x /= localNormal.z;\n"
"    //localNormal.y /= localNormal.z;\n"
"\n"
"    // # offset by the scaled localNormal and clamp it to 0.0 - 1.0\n"
"    R0 = clamp((localNormal) * (var_TexCoord2) + (R0), 0.0, 1.0); // MAD_SAT R0, localNormal, fragment.texcoord[2], R0;\n"
"\n"
"    // # scale by the screen non-power-of-two-adjust\n"
"    R0 = (R0) * (u_nonPowerOfTwo); // MUL  R0, R0, program.env[0];\n"
"\n"
"    // # load the screen render\n"
"    gl_FragColor = texture2D(u_fragmentMap0, R0.xy); // TEX  result.color.xyz, R0, texture[0], 2D;\n"
#endif
"}\n"
;

GLSL_SHADER const char HEATHAZEWITHMASK_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp mat4 u_modelViewMatrix;\n"
"uniform highp mat4 u_projectionMatrix;\n"
"\n"
"uniform highp vec4 u_vertexParm0; // texture scrolling\n"
"uniform highp vec4 u_vertexParm1; // magnitude of the distortion\n"
"\n"
"varying highp vec4 var_TexCoord0;\n"
"varying highp vec4 var_TexCoord1;\n"
"varying highp vec4 var_TexCoord2;\n"
"\n"
"// # input:\n"
"// #\n"
"// # texcoord[0] TEX0 texcoords\n"
"// #\n"
"// # local[0] scroll\n"
"// # local[1] deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
"// #\n"
"// # output:\n"
"// #\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"// # texture 2 is a mask texture\n"
"// #\n"
"// # texCoord[0] is the model surface texture coords unmodified for the mask\n"
"// # texCoord[1] is the model surface texture coords with a scroll\n"
"// # texCoord[2] is the copied deform magnitude\n"
"void main(void)\n"
"{\n"
#if HEATHAZE_BFG // BFG
"    // texture 0 takes the texture coordinates unmodified\n"
"    var_TexCoord0 = vec4( attr_TexCoord.xy, 0.0, 0.0 );\n"
"    // texture 1 takes the texture coordinates and adds a scroll\n"
"    vec4 textureScroll = u_vertexParm0;\n"
"    var_TexCoord1 = vec4( attr_TexCoord.xy, 0.0, 0.0 ) + textureScroll;\n"
"    // texture 2 takes the deform magnitude and scales it by the projection distance\n"
"    vec4 vec = vec4( 0.0, 1.0, 0.0, 1.0 );\n"
"    vec.z  = dot( attr_Vertex, u_modelViewMatrix[2] );\n"
"    // magicProjectionAdjust is a magic scalar that scales the projection since we changed from \n"
"    // using the X axis to the Y axis to calculate R1.  It is an approximation to closely match \n"
"    // what the original game did\n"
"    const float magicProjectionAdjust = 0.43;\n"
"    float x = dot ( vec, u_projectionMatrix[1] ) * magicProjectionAdjust;\n"
"    float w = dot ( vec, u_projectionMatrix[3] );\n"
"    // don't let the recip get near zero for polygons that cross the view plane\n"
"    w = max( w, 1.0 );\n"
"    x /= w;\n"
"    // clamp the distance so the the deformations don't get too wacky near the view\n"
"    x = min( x, 0.02 );\n"
"    vec4 deformMagnitude = u_vertexParm1;\n"
"    var_TexCoord2 = vec4(x) * deformMagnitude;\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"

#else // 2004

"    vec4 R0, R1, R2; // TEMP R0, R1, R2;\n"
"\n"
"    // # texture 0 takes the texture coordinates unmodified\n"
"    var_TexCoord0 = attr_TexCoord; // MOV  result.texcoord[0], vertex.texcoord[0];\n"
"\n"
"    // # texture 1 takes the texture coordinates and adds a scroll\n"
"    var_TexCoord1 = (attr_TexCoord) + (u_vertexParm0); // ADD  result.texcoord[1], vertex.texcoord[0], program.local[0];\n"
"\n"
"    // # texture 2 takes the deform magnitude and scales it by the projection distance\n"
"    vec4 vec = vec4(1.0, 0.0, 0.0, 1.0); // PARAM vec = { 1, 0, 0, 1 };\n"
"\n"
"    R0 = vec; // MOV  R0, vec;\n"
"    R0.z = dot(attr_Vertex, (u_modelViewMatrix)[2]); // DP4  R0.z, vertex.position, state.matrix.modelview.row[2];\n"
"\n"
"    R1 = vec4(dot(R0, (u_projectionMatrix)[0])); // DP4  R1, R0, state.matrix.projection.row[0];\n"
"    R2 = vec4(dot(R0, (u_projectionMatrix)[3])); // DP4  R2, R0, state.matrix.projection.row[3];\n"
"\n"
"    // # don't let the recip get near zero for polygons that cross the view plane\n"
"    R2 = max(R2, vec4(1.0)); // MAX  R2, R2, 1;\n"
"\n"
"    R2 = vec4(1.0 / R2.w); // RCP  R2, R2.w;\n"
"    R1 = (R1) * (R2); // MUL  R1, R1, R2;\n"
"\n"
"    // # clamp the distance so the the deformations don't get too wacky near the view\n"
"    R1 = min(R1, vec4(0.02)); // MIN  R1, R1, 0.02;\n"
"\n"
"    var_TexCoord2 = (R1) * (u_vertexParm1); // MUL  result.texcoord[2], R1, program.local[1];\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
#endif
"}\n"
;
GLSL_SHADER const char HEATHAZEWITHMASK_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap1;\n"
"uniform sampler2D u_fragmentMap2;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_windowCoords;\n"
"varying highp vec4 var_TexCoord0;\n"
"varying highp vec4 var_TexCoord1;\n"
"varying highp vec4 var_TexCoord2;\n"
"\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"// # texture 2 is a mask texture\n"
"// #\n"
"// # env[0] is the 1.0 to _currentRender conversion\n"
"// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"void main(void)\n"
"{\n"
#if HEATHAZE_BFG // BFG
"    // load the distortion map\n"
"    vec4 mask = texture2D( u_fragmentMap2, var_TexCoord0.xy );\n"
"    // kill the pixel if the distortion wound up being very small\n"
"    mask.xy -= 0.01;\n"
"    if ( any( lessThan( mask, vec4( 0.0 ) ) ) ) { discard; } \n"
"    // load the filtered normal map and convert to -1 to 1 range\n"
"    vec4 bumpMap = ( texture2D( u_fragmentMap1, var_TexCoord1.xy ) * 2.0 ) - 1.0;\n"
"    vec2 localNormal = bumpMap.wy;\n"
"    localNormal *= mask.xy;\n"
"    // calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    vec2 screenTexCoord = (gl_FragCoord.xy ) * u_windowCoords.xy;\n"
"    screenTexCoord += ( localNormal * var_TexCoord2.xy );\n"
"    screenTexCoord = clamp( screenTexCoord, vec2(0.0), vec2(1.0) );\n"
"    screenTexCoord = screenTexCoord * u_nonPowerOfTwo.xy;\n"
"    gl_FragColor = texture2D( u_fragmentMap0, screenTexCoord );\n"

#else // 2004

"    vec4 localNormal, mask, R0; // TEMP localNormal, mask, R0;\n"
"\n"
"    vec4 subOne = vec4(-1.0, -1.0, -1.0, -1.0); // PARAM subOne = { -1, -1, -1, -1 };\n"
"    vec4 scaleTwo = vec4(2.0, 2.0, 2.0, 2.0); // PARAM scaleTwo = { 2, 2, 2, 2 };\n"
"\n"
"    // # load the distortion map\n"
"    mask = texture2D(u_fragmentMap2, var_TexCoord0.xy); // TEX  mask, fragment.texcoord[0], texture[2], 2D;\n"
"\n"
"    // # kill the pixel if the distortion wound up being very small\n"
"    mask.xy = (mask.xy) - (vec2(0.01)); // SUB  mask.xy, mask, 0.01;\n"
"    if (any(lessThan(mask, vec4(0.0)))) discard; // KIL  mask;\n"
"\n"
"    //# load the filtered normal map and convert to -1 to 1 range\n"
"    localNormal = texture2D(u_fragmentMap1, var_TexCoord1.xy); // TEX  localNormal, fragment.texcoord[1], texture[1], 2D;\n"
"    localNormal.x = localNormal.a; // MOV  localNormal.x, localNormal.a;\n"
"    localNormal = (localNormal) * (scaleTwo) + (subOne); // MAD  localNormal, localNormal, scaleTwo, subOne;\n"
"    //localNormal.z = sqrt(max(0.0, 1.0-localNormal.x*localNormal.x-localNormal.y*localNormal.y));\n"
"    localNormal = (localNormal) * (mask); // MUL  localNormal, localNormal, mask;\n"
"\n"
"    // # calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    R0 = (gl_FragCoord) * (u_windowCoords); // MUL  R0, fragment.position, program.env[1];\n"
"\n"
"    //localNormal.x /= localNormal.z;\n"
"    //localNormal.y /= localNormal.z;\n"
"\n"
"    // # offset by the scaled localNormal and clamp it to 0.0 - 1.0\n"
"    R0 = clamp((localNormal) * (var_TexCoord2) + (R0), 0.0, 1.0); // MAD_SAT R0, localNormal, fragment.texcoord[2], R0;\n"
"\n"
"    // # scale by the screen non-power-of-two-adjust\n"
"    R0 = (R0) * (u_nonPowerOfTwo); // MUL  R0, R0, program.env[0];\n"
"\n"
"    // # load the screen render\n"
"    gl_FragColor = texture2D(u_fragmentMap0, R0.xy); // TEX  result.color.xyz, R0, texture[0], 2D;\n"
#endif
"}\n"
;

GLSL_SHADER const char HEATHAZEWITHMASKANDVERTEX_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute highp vec4 attr_Color;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp mat4 u_modelViewMatrix;\n"
"uniform highp mat4 u_projectionMatrix;\n"
"\n"
"uniform highp vec4 u_vertexParm0; // texture scrolling\n"
"uniform highp vec4 u_vertexParm1; // magnitude of the distortion\n"
"\n"
"varying highp vec4 var_TexCoord0;\n"
"varying highp vec4 var_TexCoord1;\n"
"varying highp vec4 var_TexCoord2;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"// # input:\n"
"// #\n"
"// # texcoord[0] TEX0 texcoords\n"
"// # color    vertex color for particle fading, will be multiplied by the mask texture\n"
"// #\n"
"// # local[0] scroll\n"
"// # local[1] deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
"// #\n"
"// # output:\n"
"// #\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"// # texture 2 is a mask texture\n"
"// #\n"
"// # texCoord[0] is the model surface texture coords unmodified for the mask\n"
"// # texCoord[1] is the model surface texture coords with a scroll\n"
"// # texCoord[2] is the copied deform magnitude\n"
"// # color is the copied vertex color\n"
"void main(void)\n"
"{\n"
#if HEATHAZE_BFG // BFG
"    // texture 0 takes the texture coordinates unmodified\n"
"    var_TexCoord0 = vec4( attr_TexCoord.xy, 0.0, 0.0 );\n"
"    // texture 1 takes the texture coordinates and adds a scroll\n"
"    vec4 textureScroll = u_vertexParm0;\n"
"    var_TexCoord1 = vec4( attr_TexCoord.xy, 0.0, 0.0 ) + textureScroll;\n"
"    // texture 2 takes the deform magnitude and scales it by the projection distance\n"
"    vec4 vec = vec4( 0.0, 1.0, 0.0, 1.0 );\n"
"    vec.z  = dot( attr_Vertex, u_modelViewMatrix[2] );\n"
"    // magicProjectionAdjust is a magic scalar that scales the projection since we changed from \n"
"    // using the X axis to the Y axis to calculate x.  It is an approximation to closely match \n"
"    // what the original game did\n"
"    const float magicProjectionAdjust = 0.43;\n"
"    float x = dot ( vec, u_projectionMatrix[1] ) * magicProjectionAdjust;\n"
"    float w = dot ( vec, u_projectionMatrix[3] );\n"
"    // don't let the recip get near zero for polygons that cross the view plane\n"
"    w = max( w, 1.0 );\n"
"    x /= w;\n"
"    // clamp the distance so the the deformations don't get too wacky near the view\n"
"    x = min( x, 0.02 );\n"
"    vec4 deformMagnitude = u_vertexParm1;\n"
"    var_TexCoord2 = vec4(x) * deformMagnitude;\n"
"    var_Color = attr_Color / 255.0;\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"

#else // 2004

"    vec4 R0, R1, R2; // TEMP R0, R1, R2;\n"
"\n"
"    // # texture 0 takes the texture coordinates unmodified\n"
"    var_TexCoord0 = attr_TexCoord; // MOV  result.texcoord[0], vertex.texcoord[0];\n"
"\n"
"    // # texture 1 takes the texture coordinates and adds a scroll\n"
"    var_TexCoord1 = (attr_TexCoord) + (u_vertexParm0); // ADD  result.texcoord[1], vertex.texcoord[0], program.local[0];\n"
"\n"
"    // # texture 2 takes the deform magnitude and scales it by the projection distance\n"
"    vec4 vec = vec4(1.0, 0.0, 0.0, 1.0); // PARAM vec = { 1, 0, 0, 1 };\n"
"\n"
"    R0 = vec; // MOV  R0, vec;\n"
"    R0.z = dot(attr_Vertex, (u_modelViewMatrix)[2]); // DP4  R0.z, vertex.position, state.matrix.modelview.row[2];\n"
"\n"
"    R1 = vec4(dot(R0, (u_projectionMatrix)[0])); // DP4  R1, R0, state.matrix.projection.row[0];\n"
"    R2 = vec4(dot(R0, (u_projectionMatrix)[3])); // DP4  R2, R0, state.matrix.projection.row[3];\n"
"\n"
"    // # don't let the recip get near zero for polygons that cross the view plane\n"
"    R2 = max(R2, vec4(1.0)); // MAX  R2, R2, 1;\n"
"\n"
"    R2 = vec4(1.0 / R2.w); // RCP  R2, R2.w;\n"
"    R1 = (R1) * (R2); // MUL  R1, R1, R2;\n"
"\n"
"    // # clamp the distance so the the deformations don't get too wacky near the view\n"
"    R1 = min(R1, vec4(0.02)); // MIN  R1, R1, 0.02;\n"
"\n"
"    var_TexCoord2 = (R1) * (u_vertexParm1); // MUL  result.texcoord[2], R1, program.local[1];\n"
"\n"
"    var_Color = attr_Color / 255.0; // MOV  result.color, vertex.color;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
#endif
"}\n"
;
GLSL_SHADER const char HEATHAZEWITHMASKANDVERTEX_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap1;\n"
"uniform sampler2D u_fragmentMap2;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_windowCoords;\n"
"varying highp vec4 var_TexCoord0;\n"
"varying highp vec4 var_TexCoord1;\n"
"varying highp vec4 var_TexCoord2;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"// # texture 2 is a mask texture\n"
"// #\n"
"// # env[0] is the 1.0 to _currentRender conversion\n"
"// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"void main(void)\n"
"{\n"
#if HEATHAZE_BFG // BFG
"    // load the distortion map\n"
"    vec4 mask = texture2D( u_fragmentMap2, var_TexCoord0.xy );\n"
"    // kill the pixel if the distortion wound up being very small\n"
"    mask.xy *= var_Color.xy;\n"
"    mask.xy -= 0.01;\n"
"    if ( any( lessThan( mask, vec4( 0.0 ) ) ) ) { discard; } \n"
"    // load the filtered normal map and convert to -1 to 1 range\n"
"    vec4 bumpMap = ( texture2D( u_fragmentMap1, var_TexCoord1.xy ) * 2.0 ) - 1.0;\n"
"    vec2 localNormal = bumpMap.wy;\n"
"    localNormal *= mask.xy;\n"
"    // calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    vec2 screenTexCoord = (gl_FragCoord.xy ) * u_windowCoords.xy;\n"
"    screenTexCoord += ( localNormal * var_TexCoord2.xy );\n"
"    screenTexCoord = clamp( screenTexCoord, vec2(0.0), vec2(1.0) );\n"
"    screenTexCoord = screenTexCoord * u_nonPowerOfTwo.xy;\n"
"    gl_FragColor = texture2D( u_fragmentMap0, screenTexCoord );\n"

#else // 2004

"    vec4 localNormal, mask, R0; // TEMP localNormal, mask, R0;\n"
"\n"
"    vec4 subOne = vec4(-1.0, -1.0, -1.0, -1.0); // PARAM subOne = { -1, -1, -1, -1 };\n"
"    vec4 scaleTwo = vec4(2.0, 2.0, 2.0, 2.0); // PARAM scaleTwo = { 2, 2, 2, 2 };\n"
"\n"
"    // # load the distortion map\n"
"    mask = texture2D(u_fragmentMap2, var_TexCoord0.xy); // TEX  mask, fragment.texcoord[0], texture[2], 2D;\n"
"\n"
"    // # kill the pixel if the distortion wound up being very small\n"
"    //k mask.xy *= var_Color.xy; // MUL  mask.xy, mask, fragment.color;\n"
"    mask.xy = (mask.xy) - (vec2(0.01)); // SUB  mask.xy, mask, 0.01;\n"
"    if (any(lessThan(mask, vec4(0.0)))) discard; // KIL  mask;\n"
"\n"
"    //# load the filtered normal map and convert to -1 to 1 range\n"
"    localNormal = texture2D(u_fragmentMap1, var_TexCoord1.xy); // TEX  localNormal, fragment.texcoord[1], texture[1], 2D;\n"
"    localNormal.x = localNormal.a; // MOV  localNormal.x, localNormal.a;\n"
"    localNormal = (localNormal) * (scaleTwo) + (subOne); // MAD  localNormal, localNormal, scaleTwo, subOne;\n"
"    //localNormal.z = sqrt(max(0.0, 1.0-localNormal.x*localNormal.x-localNormal.y*localNormal.y));\n"
"    localNormal = (localNormal) * (mask); // MUL  localNormal, localNormal, mask;\n"
"\n"
"    // # calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    R0 = (gl_FragCoord) * (u_windowCoords); // MUL  R0, fragment.position, program.env[1];\n"
"\n"
"    //localNormal.x /= localNormal.z;\n"
"    //localNormal.y /= localNormal.z;\n"
"\n"
"    // # offset by the scaled localNormal and clamp it to 0.0 - 1.0\n"
"    R0 = clamp((localNormal) * (var_TexCoord2) + (R0), 0.0, 1.0); // MAD_SAT R0, localNormal, fragment.texcoord[2], R0;\n"
"\n"
"    // # scale by the screen non-power-of-two-adjust\n"
"    R0 = (R0) * (u_nonPowerOfTwo); // MUL  R0, R0, program.env[0];\n"
"\n"
"    // # load the screen render\n"
"    gl_FragColor = texture2D(u_fragmentMap0, R0.xy); // TEX  result.color.xyz, R0, texture[0], 2D;\n"
#endif
"}\n"
;

// colorProcess
GLSL_SHADER const char COLORPROCESS_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute highp vec4 attr_TexCoord;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp vec4 u_vertexParm0; // fraction\n"
"uniform highp vec4 u_vertexParm1; // target hue\n"
"\n"
"varying highp vec4 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"// # parameter 0 is the fraction from the current hue to the target hue to map\n"
"// # parameter 1.rgb is the target hue\n"
"// # texture 0 is _currentRender\n"
"\n"
"// # nothing to do but pass the parameters along\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    var_Color = u_vertexParm1;\n"
"    var_TexCoord.x = attr_TexCoord.x;\n"
"    var_TexCoord.y = 1.0 - attr_TexCoord.y;\n"
"    var_TexCoord.z = u_vertexParm0.x;\n"
"}\n"
;
GLSL_SHADER const char COLORPROCESS_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"\n"
"varying highp vec4 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    vec4 src = texture2D( u_fragmentMap0, var_TexCoord.xy * u_nonPowerOfTwo.xy /* scale by the screen non-power-of-two-adjust */ );\n"
"    vec4 target = var_Color * dot( vec3( 0.333, 0.333, 0.333 ), src.xyz );\n"
"    gl_FragColor = mix( src, target, var_TexCoord.z );\n"
"}\n"
;

// interaction
GLSL_SHADER const char INTERACTION_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"//#define _PBR\n"
"//#define _AMBIENT\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying vec4 var_TexLight;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"varying vec3 var_H;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"varying vec3 var_V;\n"
"#endif\n"
"#if defined(_PBR)\n"
"varying vec3 var_Normal;\n"
"#endif\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"attribute vec3 attr_Normal;\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"\n"
"uniform vec4 u_lightProjectionS;\n"
"uniform vec4 u_lightProjectionT;\n"
"uniform vec4 u_lightFalloff;\n"
"uniform vec4 u_lightProjectionQ;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"uniform vec4 u_lightOrigin;\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"uniform vec4 u_bumpMatrixS;\n"
"uniform vec4 u_bumpMatrixT;\n"
"uniform vec4 u_diffuseMatrixS;\n"
"uniform vec4 u_diffuseMatrixT;\n"
"uniform vec4 u_specularMatrixS;\n"
"uniform vec4 u_specularMatrixT;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"#if defined(_AMBIENT)\n"
"uniform highp mat4 u_modelMatrix;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
"\n"
"    var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
"    var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
"    var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
"    var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexLight.x = dot(u_lightProjectionS, attr_Vertex);\n"
"    var_TexLight.y = dot(u_lightProjectionT, attr_Vertex);\n"
"    var_TexLight.z = dot(u_lightFalloff, attr_Vertex);\n"
"    var_TexLight.w = dot(u_lightProjectionQ, attr_Vertex);\n"
"\n"
"#if defined(_AMBIENT)\n"
"    vec3 L = normalize(vec3(0.0, 0.5, 1.0));\n"
"    var_TangentToWorldMatrix = mat3(u_modelMatrix) * M;\n"
"#else\n"
"    vec3 L = u_lightOrigin.xyz - attr_Vertex.xyz;\n"
"#endif\n"
"    vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"    vec3 H = normalize(L) + normalize(V);\n"
"#endif\n"
"\n"
"    var_L = L * M;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"    var_H = H * M;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"    var_V = V * M;\n"
"#endif\n"
"#if defined(_PBR)\n"
"    var_Normal = attr_Normal * M;\n"
"#endif\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char INTERACTION_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"//#define _PBR\n"
"//#define _AMBIENT\n"
"\n"
"//#define HALF_LAMBERT\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying vec4 var_TexLight;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"varying vec3 var_H;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"varying vec3 var_V;\n"
"#endif\n"
"#if defined(_PBR)\n"
"varying vec3 var_Normal;\n"
"#endif\n"
"\n"
"uniform vec4 u_diffuseColor;\n"
"uniform vec4 u_specularColor;\n"
"#if defined(_PBR)\n"
"uniform vec4 u_specularExponent;\n"
"#else\n"
"uniform float u_specularExponent;\n"
"#endif\n"
"\n"
"uniform sampler2D u_fragmentMap0;    /* u_bumpTexture */\n"
"uniform sampler2D u_fragmentMap1;    /* u_lightFalloffTexture */\n"
"uniform sampler2D u_fragmentMap2;    /* u_lightProjectionTexture */\n"
"uniform sampler2D u_fragmentMap3;    /* u_diffuseTexture */\n"
"#if defined(_AMBIENT)\n"
"uniform samplerCube u_fragmentCubeMap4;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"#else\n"
"uniform sampler2D u_fragmentMap4;    /* u_specularTexture */\n"
"uniform sampler2D u_fragmentMap5;    /* u_specularFalloffTexture */\n"
"#endif\n"
"\n"
"#if defined(_PBR)\n"
_PBR_GENERAL_FUNCTION
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    //float u_specularExponent = 4.0;\n"
"\n"
"    vec3 L = normalize(var_L);\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"    vec3 H = normalize(var_H);\n"
"#endif\n"
"#if defined(BLINN_PHONG) || defined(_AMBIENT)\n"
"    vec3 N = 2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"    vec3 V = normalize(var_V);\n"
"    vec3 N = normalize(2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0);\n"
"#endif\n"
"\n"
"#if defined(_AMBIENT)\n"
"    vec3 globalNormal = var_TangentToWorldMatrix * N; // transform into ambient map space\n"
"    vec3 ambientValue = textureCube(u_fragmentCubeMap4, globalNormal).rgb; // load the ambient value\n"
"#endif\n"
"\n"
"    float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
"#if defined(HALF_LAMBERT)\n"
"    NdotL *= 0.5;\n"
"    NdotL += 0.5;\n"
"    NdotL = NdotL * NdotL;\n"
"#endif\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
"#endif\n"
"\n"
"    vec3 lightProjection = texture2DProj(u_fragmentMap2, var_TexLight.xyw).rgb;\n"
"    vec3 lightFalloff = texture2D(u_fragmentMap1, vec2(var_TexLight.z, 0.5)).rgb;\n"
"    vec3 diffuseColor = texture2D(u_fragmentMap3, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
"#if defined(_PBR)\n"
"    vec3 AN = normalize(mix(normalize(var_Normal), N, u_specularExponent.y));\n"
"    vec4 Cd = vec4(diffuseColor.rgb, 1.0);\n"
"    vec4 specTex = texture2D(u_fragmentMap4, var_TexSpecular);\n"
"    vec4 roughness = vec4(clamp(specTex.r * (sign(1.0 - abs(sign(u_specularExponent.z))) * 2.0 - 1.0) /* if max == 0, result = 1; else result = -1 */ + u_specularExponent.z, 0.0, 1.0)) * max(sign(specTex.r), 0.0) /* if specularTex.r == 0, result = 0, else result = 1 */; // roughness = max - specularTex.r, but if specularTex.r == 0, roughness = 0\n"
"    vec4 metallic = vec4(clamp(specTex.g + u_specularExponent.w, 0.0, 1.0)) * max(sign(specTex.g), 0.0) /* if specularTex.g == 0, result = 0, else result = 1 */; // metallic = specularTex.r, but if specularTex.r == 0, metallic = 0\n"
"\n"
"    vec4 Cl = vec4(lightProjection * lightFalloff, 1.0);\n"
"    vec3 F0 = vec3(0.04); \n"
"    F0 = mix(F0, Cd.xyz, metallic.xyz);\n"
"\n"
"    // cook-torrance brdf\n"
"    float NDF = DistributionGGX(AN, H, roughness.x);        \n"
"    float G   = GeometrySmith(AN, V, L, roughness.x);      \n"
"    vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //max       \n"
"\n"
"    vec3 kS = F;\n"
"    vec3 kD = vec3(1.0) - kS;\n"
"    kD *= 1.0 - metallic.r;\n"
"\n"
"    vec3 numerator    = NDF * G * F;\n"
"    float denominator = 4.0 * max(dot(AN, V), 0.0) * max(dot(AN, L), 0.0);\n"
"    vec3 pbr     = numerator / max(denominator, 0.001);  \n"
"\n"
"#if 1\n"
"    vec4 Lo = (Cd/* * vec4(kD, 1.0)*/ + (u_specularExponent.x * vec4(pbr.rgb, 0.0) * u_specularColor)) * NdotL * Cl;\n"
"    gl_FragColor = vec4(Lo.rgb, 1.0) * var_Color;\n"
"#else\n"
"    gl_FragColor = var_Color * Cl * NdotL * Cd + (u_specularExponent.x * vec4(pbr.rgb, 0.0) * (u_specularColor/* * Cl*/));\n"
"#endif\n"
"#elif defined(_AMBIENT)\n"
"    vec3 color = u_specularExponent * /*ambientValue * */diffuseColor * lightProjection * lightFalloff;\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"#else\n"
"    vec3 specularColor = 2.0 * texture2D(u_fragmentMap4, var_TexSpecular).rgb * u_specularColor.rgb;\n"
"\n"
"#if defined(BLINN_PHONG)\n"
"    float specularFalloff = pow(NdotH, u_specularExponent);\n"
"#else\n"
"    vec3 R = -reflect(L, N);\n"
"    float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
"    float specularFalloff = pow(RdotV, u_specularExponent);\n"
"#endif\n"
"\n"
"    vec3 color;\n"
"    color = diffuseColor;\n"
"    color += specularFalloff * specularColor;\n"
"    color *= NdotL * lightProjection;\n"
"    color *= lightFalloff;\n"
"\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"#endif\n"
"}\n"
;

// z-fill
GLSL_SHADER const char ZFILL_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform mat4 u_textureMatrix;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"\n"
"void main(void)\n"
"{\n"
"    var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ZFILL_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp float u_alphaTest;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"\n"
"void main(void)\n"
"{\n"
"    if (u_alphaTest > texture2D(u_fragmentMap0, var_TexDiffuse).a) {\n"
"        discard;\n"
"    }\n"
"\n"
"    gl_FragColor = u_glColor;\n"
"}\n"
;

// cubemap
GLSL_SHADER const char CUBEMAP_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute lowp vec4 attr_Color;\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"varying vec3 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"  var_TexCoord = (u_textureMatrix * attr_TexCoord).xyz;\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char CUBEMAP_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"varying vec3 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"uniform samplerCube u_fragmentCubeMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_FragColor = textureCube(u_fragmentCubeMap0, var_TexCoord) * u_glColor * var_Color;\n"
"}\n"
;

// reflection cubemap(environment)
GLSL_SHADER const char ENVIRONMENT_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"attribute vec3 attr_TexCoord;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_modelViewMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"varying vec3 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_normalLocal;\n"
"varying vec3 var_toEyeLocal;\n"
"\n"
"void main(void)\n"
"{\n"
"#if 1\n"
"    var_normalLocal = attr_Normal;\n"
"    var_toEyeLocal = vec3(u_viewOrigin - attr_Vertex);\n"
"#else // d3asm\n"
"    var_TexCoord = (u_textureMatrix * reflect( normalize( u_modelViewMatrix * attr_Vertex ),\n"
"    // This suppose the modelView matrix is orthogonal\n"
"    // Otherwise, we should use the inverse transpose\n"
"        u_modelViewMatrix * vec4(attr_TexCoord,0.0) )).xyz ;\n"
"#endif\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ENVIRONMENT_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"varying vec3 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_normalLocal;\n"
"varying vec3 var_toEyeLocal;\n"
"\n"
"uniform samplerCube u_fragmentCubeMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"void main(void)\n"
"{\n"
"#if 1\n"
"    // normalize surface normal\n"
"    vec3 normal = normalize(var_normalLocal);\n"
"    // normalize vector to eye\n"
"    vec3 toEye = normalize(var_toEyeLocal);\n"
"\n"
"    // calculate reflection vector\n"
"    float dotEN = dot(toEye, normal);\n"
"    vec3 reflectionVector = vec3(2.0) * normal * vec3(dotEN) - toEye;\n"
"\n"
"    gl_FragColor = textureCube(u_fragmentCubeMap0, reflectionVector) * u_glColor * var_Color;\n"
"#else // d3asm\n"
"    gl_FragColor = textureCube(u_fragmentCubeMap0, var_TexCoord) * u_glColor * var_Color;\n"
"#endif\n"
"}\n"
;

// reflection cubemap(bumpyEnvironment)
GLSL_SHADER const char BUMPY_ENVIRONMENT_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"attribute vec3 attr_Normal;\n"
"attribute vec2 attr_TexCoord;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp mat4 u_modelMatrix;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"varying highp vec3 var_toEyeWorld; //karin: must highp in GLES\n"
"\n"
"void main(void)\n"
"{\n"
"    // texture 0 takes the unodified texture coordinates\n"
"    var_TexCoord = attr_TexCoord;\n"
"\n"
"    // texture 1 is the vector to the eye in global coordinates\n"
"    var_toEyeWorld = mat3(u_modelMatrix) * vec3(u_viewOrigin - attr_Vertex);\n"
"\n"
"    // texture 2 3 4 gets the transformed tangent\n"
"    mat3 matTangentToLocal = mat3(\n"
"        clamp(attr_Tangent, vec3(-1.0), vec3(1.0)),\n"
"        clamp(attr_Bitangent, vec3(-1.0), vec3(1.0)),\n"
"        clamp(attr_Normal, vec3(-1.0), vec3(1.0))\n"
"    );\n"
"    var_TangentToWorldMatrix = mat3(u_modelMatrix) * matTangentToLocal;\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char BUMPY_ENVIRONMENT_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"varying highp vec3 var_toEyeWorld; //karin: must highp in GLES\n"
"\n"
"uniform samplerCube u_fragmentCubeMap0;\n"
"uniform sampler2D u_fragmentMap1; // normal map\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"void main(void)\n"
"{\n"
"    // per-pixel cubic reflextion map calculation\n"
"\n"
"    // texture 0 is the environment cube map\n"
"    // texture 1 is the normal map\n"
"\n"
"    // load the filtered normal map, then normalize to full scale,\n"
"    vec3 localNormal = texture2D(u_fragmentMap1, var_TexCoord).agb; // doom3's normal map is not rgb\n"
"    localNormal = localNormal * vec3(2.0) - vec3(1.0);\n"
"    localNormal.z = sqrt(max(0.0, 1.0 - localNormal.x * localNormal.x - localNormal.y * localNormal.y));\n"
"    localNormal = normalize(localNormal);\n"
"\n"
"    // transform the surface normal by the local tangent space\n"
"    vec3 globalNormal = var_TangentToWorldMatrix * localNormal;\n"
"\n"
"    // normalize vector to eye\n"
"    vec3 globalEye = normalize(var_toEyeWorld);\n"
"\n"
"    // calculate reflection vector\n"
"    float dotEN = dot(globalEye, globalNormal);\n"
"    vec3 globalReflect = 2.0 * (dotEN * globalNormal) - globalEye;\n"
"\n"
"    // read the environment map with the reflection vector\n"
"    vec3 reflectedColor = textureCube(u_fragmentCubeMap0, globalReflect).rgb;\n"
"\n"
"#if 0 // TDM\n"
"    // calculate fresnel reflectance.\n"
"    float q = 1.0 - dotEN;\n"
"    float fresnel = 3.0 * q * q * q * q;\n"
"    reflectedColor *= (fresnel + 0.4);\n"
"\n"
"    // tonemap to convert HDR values to range 0.0 - 1.0\n"
"    gl_FragColor = vec4(reflectedColor / (vec3(1.0) + reflectedColor), 1.0) * u_glColor * var_Color;\n"
"#else // original DOOM3\n"
"    gl_FragColor = vec4(reflectedColor, 1.0)/* * u_glColor * var_Color */;\n"
"#endif\n"
"}\n"
;

// fog
GLSL_SHADER const char FOG_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;      // input Vertex Coordinates\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_fogMatrix;        // fogPlanes 0, 1, 3 (CATION: not 2!), 2\n"
"\n"
"varying vec2 var_TexFog;         // output Fog TexCoord\n"
"varying vec2 var_TexFogEnter;    // output FogEnter TexCoord\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    // What will be computed:\n"
"    //\n"
"    // var_TexFog.x      = dot(u_fogMatrix[0], attr_Vertex);\n"
"    // var_TexFog.y      = dot(u_fogMatrix[1], attr_Vertex);\n"
"    // var_TexFogEnter.x = dot(u_fogMatrix[2], attr_Vertex);\n"
"    // var_TexFogEnter.y = dot(u_fogMatrix[3], attr_Vertex);\n"
"\n"
"    // Optimized version:\n"
"    var_TexFog      = vec2(dot(u_fogMatrix[0], attr_Vertex),dot(u_fogMatrix[1], attr_Vertex));\n"
"    var_TexFogEnter = vec2(dot(u_fogMatrix[2], attr_Vertex),dot(u_fogMatrix[3], attr_Vertex));\n"
"}\n"
;
GLSL_SHADER const char FOG_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"varying vec2 var_TexFog;            // input Fog TexCoord\n"
"varying vec2 var_TexFogEnter;       // input FogEnter TexCoord\n"
"\n"
"uniform sampler2D u_fragmentMap0;   // Fog Image\n"
"uniform sampler2D u_fragmentMap1;   // Fog Enter Image\n"
"uniform lowp vec4 u_fogColor;       // Fog Color\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_FragColor = texture2D( u_fragmentMap0, var_TexFog ) * texture2D( u_fragmentMap1, var_TexFogEnter ) * vec4(u_fogColor.rgb, 1.0);\n"
"}\n"
;

// blend light
GLSL_SHADER const char BLENDLIGHT_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_fogMatrix;\n"
"\n"
"varying vec2 var_TexFog;\n"
"varying vec2 var_TexFogEnter;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    // What will be computed:\n"
"    //\n"
"    // vec4 tc;\n"
"    // tc.x = dot( u_fogMatrix[0], attr_Vertex );\n"
"    // tc.y = dot( u_fogMatrix[1], attr_Vertex );\n"
"    // tc.z = 0.0;\n"
"    // tc.w = dot( u_fogMatrix[2], attr_Vertex );\n"
"    // var_TexFog.xy = tc.xy / tc.w;\n"
"    //\n"
"    // var_TexFogEnter.x = dot( u_fogMatrix[3], attr_Vertex );\n"
"    // var_TexFogEnter.y = 0.5;\n"
"\n"
"    // Optimized version:\n"
"    //\n"
"    var_TexFog = vec2(dot( u_fogMatrix[0], attr_Vertex ), dot( u_fogMatrix[1], attr_Vertex )) / dot( u_fogMatrix[2], attr_Vertex );\n"
"    var_TexFogEnter = vec2( dot( u_fogMatrix[3], attr_Vertex ), 0.5 );\n"
"}\n"
;

// z-fill with clip plane
GLSL_SHADER const char ZFILLCLIP_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute vec4 attr_TexCoord;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform vec4 u_clipPlane;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexClip;\n"
"\n"
"void main(void)\n"
"{\n"
"    var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
"    var_TexClip = vec2( dot( u_clipPlane, attr_Vertex), 0.5 );\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char ZFILLCLIP_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexClip;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap1;\n"
"uniform lowp float u_alphaTest;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"void main(void)\n"
"{\n"
"    if (u_alphaTest > (texture2D(u_fragmentMap0, var_TexDiffuse).a * texture2D(u_fragmentMap1, var_TexClip).a) ) {\n"
      "discard;\n"
"    }\n"
"\n"
"    gl_FragColor = u_glColor;\n"
"}\n"
;

// diffuse dubemap(UNUSED in game)
GLSL_SHADER const char DIFFUSE_CUBEMAP_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"// In\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"attribute vec3 attr_TexCoord;\n"
"\n"
"// Uniforms\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"\n"
"// Out\n"
"// gl_Position\n"
"varying vec3 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    var_TexCoord = (u_textureMatrix * vec4(attr_TexCoord, 0.0)).xyz;\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;

// texgen(Only used in D3XP)
GLSL_SHADER const char TEXGEN_VERT[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform vec4 u_texgenS;\n"
"uniform vec4 u_texgenT;\n"
"uniform vec4 u_texgenQ;\n"
"uniform mat4 u_textureMatrix;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"varying vec4 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    vec4 texcoord0 = vec4(dot( u_texgenS, attr_Vertex ), dot( u_texgenT, attr_Vertex ), 0.0, dot( u_texgenQ, attr_Vertex )); \n"
"\n"
"    // multiply the texture matrix in\n"
"    var_TexCoord = vec4(dot( u_textureMatrix[0], texcoord0 ), dot( u_textureMatrix[1], texcoord0), texcoord0.z, texcoord0.w);\n"
"\n"
"    // compute vertex modulation\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"}\n"
;
GLSL_SHADER const char TEXGEN_FRAG[] = 
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"varying vec4 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    // we always do a projective texture lookup so that we can support texgen\n"
"    // materials without a separate shader. Basic materials will have texture\n"
"    // coordinates with w = 1 which will result in a NOP projection when tex2Dproj\n"
"    // gets called.\n"
"    gl_FragColor = texture2DProj( u_fragmentMap0, var_TexCoord.xyw ) * u_glColor * var_Color;\n"
"}\n"
;

// megatexture
GLSL_SHADER const char MEGATEXTURE_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute vec4 attr_TexCoord;\n"
"attribute lowp vec4 attr_Color;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform vec4 u_megaTextureLevel0;\n"
"uniform vec4 u_megaTextureLevel1;\n"
"uniform vec4 u_megaTextureLevel2;\n"
"uniform vec4 u_megaTextureLevel3;\n"
"uniform vec4 u_megaTextureLevel4;\n"
"uniform vec4 u_megaTextureLevel5;\n"
"uniform vec4 u_megaTextureLevel6;\n"
"uniform vec4 u_megaTextureLevel7;\n"
"uniform vec4 u_megaTextureLevel8;\n"
"\n"
"varying vec4 var_TexCoord0;\n"
"varying vec4 var_TexCoord1;\n"
"varying vec4 var_TexCoord2;\n"
"varying vec4 var_TexCoord3;\n"
"varying vec4 var_TexCoord4;\n"
"varying vec4 var_TexCoord5;\n"
"varying vec4 var_TexCoord6;\n"
"varying vec4 var_TexCoord7;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    // Megatexture masks, (texCoord * scale) + offset.\n"
"    var_TexCoord0.xy = ( attr_TexCoord.xy * u_megaTextureLevel0.w ) + u_megaTextureLevel0.xy;\n"
"    var_TexCoord1.xy = ( attr_TexCoord.xy * u_megaTextureLevel1.w ) + u_megaTextureLevel1.xy;\n"
"    var_TexCoord2.xy = ( attr_TexCoord.xy * u_megaTextureLevel2.w ) + u_megaTextureLevel2.xy;\n"
"    var_TexCoord3.xy = ( attr_TexCoord.xy * u_megaTextureLevel3.w ) + u_megaTextureLevel3.xy;\n"
"    var_TexCoord4.xy = ( attr_TexCoord.xy * u_megaTextureLevel4.w ) + u_megaTextureLevel4.xy;\n"
"    var_TexCoord5.xy = ( attr_TexCoord.xy * u_megaTextureLevel5.w ) + u_megaTextureLevel5.xy;\n"
"    var_TexCoord6.xy = ( attr_TexCoord.xy * u_megaTextureLevel6.w ) + u_megaTextureLevel6.xy;\n"
"\n"
"    // Images only have scale.\n"
"    var_TexCoord7.xy = ( attr_TexCoord.xy * u_megaTextureLevel6.w );\n"
"    var_TexCoord7.zw = attr_TexCoord.xy;\n"
"}\n"
;
GLSL_SHADER const char MEGATEXTURE_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define ConvertYCoCgToRGB(x) x.rgb\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap1;\n"
"uniform sampler2D u_fragmentMap2;\n"
"uniform sampler2D u_fragmentMap3;\n"
"uniform sampler2D u_fragmentMap4;\n"
"uniform sampler2D u_fragmentMap5;\n"
"uniform sampler2D u_fragmentMap6;\n"
"uniform sampler2D u_fragmentMap7;\n"
"\n"
"varying vec4 var_TexCoord0;\n"
"varying vec4 var_TexCoord1;\n"
"varying vec4 var_TexCoord2;\n"
"varying vec4 var_TexCoord3;\n"
"varying vec4 var_TexCoord4;\n"
"varying vec4 var_TexCoord5;\n"
"varying vec4 var_TexCoord6;\n"
"varying vec4 var_TexCoord7;\n"
"\n"
"void main(void)\n"
"{\n"
"    vec4 mask1, mask2;\n"
"    vec4 invMask1, invMask2;\n"
"    vec4 combined;\n"
"    vec2 scaled;\n"
"    vec4 R2;\n"
"\n"
"    mask1.x = texture2D(u_fragmentMap0, var_TexCoord0.xy).x;\n"
"    mask1.y = texture2D(u_fragmentMap0, var_TexCoord1.xy).x;\n"
"    mask1.z = texture2D(u_fragmentMap0, var_TexCoord2.xy).x;\n"
"    mask1.w = texture2D(u_fragmentMap0, var_TexCoord3.xy).x;\n"
"\n"
"    mask2.x = texture2D(u_fragmentMap0, var_TexCoord4.xy).x;\n"
"    mask2.y = texture2D(u_fragmentMap0, var_TexCoord5.xy).x;\n"
"    mask2.z = texture2D(u_fragmentMap0, var_TexCoord6.xy).x;\n"
"    mask2.w = 1.0;\n"
"\n"
"    invMask1 = 1.0 - mask1;\n"
"    invMask2 = 1.0 - mask2;\n"
"\n"
"    combined = vec4(0.0);\n"
"    scaled = var_TexCoord7.zw;\n"
"\n"
"    // Sample the lowest quality first.\n"
"    R2 = texture2D(u_fragmentMap1, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask1.x;\n"
"    combined = (R2 * mask1.x) + combined;\n"
"\n"
"    R2 = texture2D(u_fragmentMap2, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask1.y;\n"
"    combined = (R2 * mask1.y) + combined;\n"
"\n"
"    R2 = texture2D(u_fragmentMap3, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask1.z;\n"
"    combined = (R2 * mask1.z) + combined;\n"
"\n"
"    R2 = texture2D(u_fragmentMap4, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask1.w;\n"
"    combined = (R2 * mask1.w) + combined;\n"
"\n"
"    R2 = texture2D(u_fragmentMap5, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask2.x;\n"
"    combined = (R2 * mask2.x) + combined;\n"
"\n"
"    R2 = texture2D(u_fragmentMap6, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask2.y;\n"
"    combined = (R2 * mask2.y) + combined;\n"
"\n"
"    R2 = texture2D(u_fragmentMap7, scaled.xy);\n"
"    R2.xyz = ConvertYCoCgToRGB(R2);\n"
"    scaled = scaled * 2.0;\n"
"    combined = combined * invMask2.z;\n"
"    combined = (R2 * mask2.z) + combined;\n"
"\n"
"    gl_FragColor = combined;\n"
"}\n"
;

GLSL_SHADER const char PLAIN_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute lowp vec4 attr_Color;\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    var_TexDiffuse = attr_TexCoord.xy;\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char PLAIN_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_FragColor = texture2D(u_fragmentMap0, var_TexDiffuse) * u_glColor * var_Color;\n"
"}\n"
;



#if 0
#define SAMPLE_POISSON_DISK \
        "#define SAMPLES 9\n" \
        "    vec2 sampleOffsetTable[SAMPLES];\n" \
        "    sampleOffsetTable[0] = vec2( 0.0, 0.0);\n" \
        "    sampleOffsetTable[1] = vec2( 1.0, 1.0); sampleOffsetTable[2] = vec2( 1.0, -1.0); sampleOffsetTable[3] = vec2(-1.0, -1.0); sampleOffsetTable[4] = vec2(-1.0, 1.0);\n" \
        "    sampleOffsetTable[5] = vec2( 1.0, 0.0); sampleOffsetTable[6] = vec2( -1.0, 0.0); sampleOffsetTable[7] = vec2(0.0, -1.0); sampleOffsetTable[8] = vec2(0.0, 1.0);\n"
#endif
#define SHADOW_MAPPING_SAMPLE_POISSON_DISK \
        "#define SAMPLES 12\n" \
        "#define SAMPLE_MULTIPLICATOR (1.0 / 12.0)\n" \
        "vec2 sampleOffsetTable[SAMPLES];\n" \
		"sampleOffsetTable[0] = vec2( 0.6111618, 0.1050905 );\n" \
		"sampleOffsetTable[1] = vec2( 0.1088336, 0.1127091 );\n" \
		"sampleOffsetTable[2] = vec2( 0.3030421, -0.6292974 );\n" \
		"sampleOffsetTable[3] = vec2( 0.4090526, 0.6716492 );\n" \
		"sampleOffsetTable[4] = vec2( -0.1608387, -0.3867823 );\n" \
		"sampleOffsetTable[5] = vec2( 0.7685862, -0.6118501 );\n" \
		"sampleOffsetTable[6] = vec2( -0.1935026, -0.856501 );\n" \
		"sampleOffsetTable[7] = vec2( -0.4028573, 0.07754025 );\n" \
		"sampleOffsetTable[8] = vec2( -0.6411021, -0.4748057 );\n" \
		"sampleOffsetTable[9] = vec2( -0.1314865, 0.8404058 );\n" \
		"sampleOffsetTable[10] = vec2( -0.7005203, 0.4596822 );\n" \
		"sampleOffsetTable[11] = vec2( -0.9713828, -0.06329931 );\n" \
		"// sampleOffsetTable[12] = vec2( 0.0, 0.0 );\n"
#define STENCIL_SHADOW_SAMPLE_POISSON_DISK \
        "#define SAMPLES 16\n" \
        "#define SAMPLE_MULTIPLICATOR (1.0 / 16.0)\n" \
        "vec2 sampleOffsetTable[SAMPLES];\n" \
		"sampleOffsetTable[0] = vec2( -0.94201624, -0.39906216 );\n" \
		"sampleOffsetTable[1] = vec2( 0.94558609, -0.76890725 );\n" \
		"sampleOffsetTable[2] = vec2( -0.094184101, -0.92938870 );\n" \
		"sampleOffsetTable[3] = vec2( 0.34495938, 0.29387760 );\n" \
		"sampleOffsetTable[4] = vec2( -0.91588581, 0.45771432 );\n" \
		"sampleOffsetTable[5] = vec2( -0.81544232, -0.87912464 );\n" \
		"sampleOffsetTable[6] = vec2( -0.38277543, 0.27676845 );\n" \
		"sampleOffsetTable[7] = vec2( 0.97484398, 0.75648379 );\n" \
		"sampleOffsetTable[8] = vec2( 0.44323325, -0.97511554 );\n" \
		"sampleOffsetTable[9] = vec2( 0.53742981, -0.47373420 );\n" \
		"sampleOffsetTable[10] = vec2( -0.26496911, -0.41893023 );\n" \
		"sampleOffsetTable[11] = vec2( 0.79197514, 0.19090188 );\n" \
		"sampleOffsetTable[12] = vec2( -0.24188840, 0.99706507 );\n" \
		"sampleOffsetTable[13] = vec2( -0.81409955, 0.91437590 );\n" \
		"sampleOffsetTable[14] = vec2( 0.19984126, 0.78641367 );\n" \
		"sampleOffsetTable[15] = vec2( 0.14383161, -0.14100790 );\n" \
		"// sampleOffsetTable[16] = vec2( 0.0, 0.0 );\n"
#if 1
#define SHADOW_MAPPING_SAMPLE_CUBE_POISSON_DISK \
"    #define SAMPLES 20\n" \
"    #define SAMPLE_MULTIPLICATOR (1.0 / 20.0)\n" \
"    vec3 sampleOffsetTable[SAMPLES];\n" \
"    sampleOffsetTable[0] = vec3(1.0, 1.0, 1.0); sampleOffsetTable[1] = vec3(1.0, -1.0, 1.0); sampleOffsetTable[2] = vec3(-1.0, -1.0, 1.0); sampleOffsetTable[3] = vec3(-1.0, 1.0, 1.0);\n" \
"    sampleOffsetTable[4] = vec3(1.0, 1.0, -1.0); sampleOffsetTable[5] = vec3(1.0, -1.0, -1.0); sampleOffsetTable[6] = vec3(-1.0, -1.0, -1.0); sampleOffsetTable[7] = vec3(-1.0, 1.0, -1.0);\n" \
"    sampleOffsetTable[8] = vec3(1.0, 1.0, 0.0); sampleOffsetTable[9] = vec3(1.0, -1.0, 0.0); sampleOffsetTable[10] = vec3(-1.0, -1.0, 0.0); sampleOffsetTable[11] = vec3(-1.0, 1.0, 0.0);\n" \
"    sampleOffsetTable[12] = vec3(1.0, 0.0, 1.0); sampleOffsetTable[13] = vec3(-1.0, 0.0, 1.0); sampleOffsetTable[14] = vec3(1.0, 0.0, -1.0); sampleOffsetTable[15] = vec3(-1.0, 0.0, -1.0);\n" \
"    sampleOffsetTable[16] = vec3(0.0, 1.0, 1.0); sampleOffsetTable[17] = vec3(0.0, -1.0, 1.0); sampleOffsetTable[18] = vec3(0.0, -1.0, -1.0); sampleOffsetTable[19] = vec3(0.0, 1.0, -1.0);\n" \
"    // sampleOffsetTable[20] = vec3(0.0, 0.0, 0.0);\n"
#else
#define SHADOW_MAPPING_SAMPLE_CUBE_POISSON_DISK \
        "    #define SAMPLES 8\n" \
        "    #define SAMPLE_MULTIPLICATOR (1.0 / 8.0)\n" \
        "    vec3 sampleOffsetTable[SAMPLES];\n" \
        "    sampleOffsetTable[0] = vec3(1.0, 1.0, 1.0); sampleOffsetTable[1] = vec3(1.0, 1.0, -1.0); sampleOffsetTable[2] = vec3(1.0, -1.0, -1.0); sampleOffsetTable[3] = vec3(1.0, -1.0, 1.0);\n" \
        "    sampleOffsetTable[4] = vec3(-1.0, 1.0, 1.0); sampleOffsetTable[5] = vec3(-1.0, -1.0, 1.0); sampleOffsetTable[6] = vec3(-1.0, 1.0, -1.0); sampleOffsetTable[7] = vec3(-1.0, -1.0, -1.0);\n" \
        "    // sampleOffsetTable[8] = vec3(0.0, 0.0, 0.0);\n"
#endif

#ifdef _SHADOW_MAPPING
#define PACK_FLOAT_FUNC() \
"vec4 pack (highp float depth)\n" \
"{\n" \
"    const highp vec4 bitSh = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n" \
"    const highp vec4 bitMsk = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n" \
"    highp vec4 comp = fract(depth * bitSh);\n" \
"    comp -= comp.xxyz * bitMsk;\n" \
"    return depth < 1.0 ? comp : vec4(1.0, 1.0, 1.0, 1.0);\n" \
"}\n"
#define UNPACK_FLOAT_FUNC() \
"highp float unpack (vec4 colour)\n" \
"{\n" \
"    const highp vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n" \
"    highp float dotc = dot(colour , bitShifts);\n" \
"    return /*all(lessThan(colour, vec4(1.0, 1.0, 1.0, 1.0)))*/ colour.r < 1.0 ? dotc : 1.0;\n" \
"}\n"

#define VECTOR_TO_DEPTH_FUNC(far, near) \
"float VectorToDepthValue(vec3 Vec)\n" \
"{\n" \
"    vec3 AbsVec = abs(Vec);\n" \
"    float LocalZcomp = max(AbsVec.x, max(AbsVec.y, AbsVec.z));\n" \
"    float NormZComp = (" #far " + " #near ") / (" #far " - " #near ") - (2.0 * " #far " * " #near ") / (" #far " - " #near ") / LocalZcomp;\n" \
"    return (NormZComp + 1.0) * 0.5;\n" \
"}\n"

// shadow map
GLSL_SHADER const char DEPTH_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp vec4 u_lightOrigin;\n"
"\n"
"// uniform lowp float u_uniformParm0; // .w 1.0 or 0.0\n"
"\n"
"void main(void)\n"
"{\n"
"    highp vec4 pos;\n"
"    //pos = attr_Vertex.w * u_lightOrigin + attr_Vertex - u_lightOrigin;\n"
"    //float w = max(attr_Vertex.w, u_uniformParm0);\n"
"    //pos = w * u_lightOrigin + vec4(attr_Vertex.xyz, w) - u_lightOrigin;\n"
"    //pos = attr_Vertex - u_lightOrigin; pos = (pos.wwww * u_lightOrigin) + pos;\n"
"    pos = vec4(attr_Vertex.xyz, 1.0);\n"
"    gl_Position = pos * u_modelViewProjectionMatrix;\n"
"}\n"
;
GLSL_SHADER const char DEPTH_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"//#define _USING_DEPTH_TEXTURE\n"
"//#define _PACK_FLOAT\n"
"\n"
"precision highp float;\n"
"\n"
"#ifdef _PACK_FLOAT\n"
PACK_FLOAT_FUNC()
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"#ifdef _USING_DEPTH_TEXTURE\n"
"   #ifdef _DEBUG\n"
"       gl_FragColor = vec4((gl_FragCoord.z + 1.0) * 0.5, 0.0, 0.0, 1.0); // DEBUG\n"
"   #endif\n"
"#else\n"
"    highp float depth;\n"
"    depth = gl_FragCoord.z;\n"
"   #ifdef _PACK_FLOAT\n"
"        gl_FragColor = pack(depth);\n"
"   #else\n"
"        gl_FragColor = vec4(depth, 0.0, 0.0, 1.0);\n"
"   #endif\n"
"#endif\n"
"}\n"
;

// interaction(shadow mapping)
GLSL_SHADER const char INTERACTION_SHADOW_MAPPING_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"//#define _PBR\n"
"//#define _AMBIENT\n"
"//#define _POINT_LIGHT\n"
"//#define _SPOT_LIGHT\n"
"//#define _PARALLEL_LIGHT\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying vec4 var_TexLight;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"varying vec3 var_H;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"varying vec3 var_V;\n"
"#endif\n"
"#if defined(_PBR)\n"
"varying vec3 var_Normal;\n"
"#endif\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"attribute vec3 attr_Normal;\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"\n"
"uniform vec4 u_lightProjectionS;\n"
"uniform vec4 u_lightProjectionT;\n"
"uniform vec4 u_lightFalloff;\n"
"uniform vec4 u_lightProjectionQ;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"uniform vec4 u_lightOrigin;\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"uniform vec4 u_bumpMatrixS;\n"
"uniform vec4 u_bumpMatrixT;\n"
"uniform vec4 u_diffuseMatrixS;\n"
"uniform vec4 u_diffuseMatrixT;\n"
"uniform vec4 u_specularMatrixS;\n"
"uniform vec4 u_specularMatrixT;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"#if defined(_AMBIENT)\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"#endif\n"
"\n"
"uniform highp mat4 u_modelMatrix;\n"
"uniform highp vec4 globalLightOrigin;\n"
"\n"
"#ifdef _POINT_LIGHT\n"
"    varying highp vec3 var_LightToVertex;\n"
"    varying highp vec4 var_VertexPosition;\n"
"#else\n"
"    uniform highp mat4 shadowMVPMatrix;\n"
"    varying highp vec4 var_ShadowCoord;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
"\n"
"    var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
"    var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
"    var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
"    var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexLight.x = dot(u_lightProjectionS, attr_Vertex);\n"
"    var_TexLight.y = dot(u_lightProjectionT, attr_Vertex);\n"
"    var_TexLight.z = dot(u_lightFalloff, attr_Vertex);\n"
"    var_TexLight.w = dot(u_lightProjectionQ, attr_Vertex);\n"
"\n"
"#if defined(_AMBIENT)\n"
"    vec3 L = normalize(vec3(0.0, 0.5, 1.0));\n"
"    var_TangentToWorldMatrix = mat3(u_modelMatrix) * M;\n"
"#else\n"
"    vec3 L = u_lightOrigin.xyz - attr_Vertex.xyz;\n"
"#endif\n"
"    vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"    vec3 H = normalize(L) + normalize(V);\n"
"#endif\n"
"\n"
"    var_L = L * M;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"    var_H = H * M;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"    var_V = V * M;\n"
"#endif\n"
"#if defined(_PBR)\n"
"    var_Normal = attr_Normal * M;\n"
"#endif\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"#ifdef _POINT_LIGHT\n"
"    highp vec4 posInLight = u_modelMatrix * attr_Vertex;\n"
"    var_LightToVertex = posInLight.xyz - globalLightOrigin.xyz;\n"
"    var_VertexPosition = attr_Vertex;\n"
"#else\n"
"    var_ShadowCoord = attr_Vertex * shadowMVPMatrix;\n"
"#endif\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char INTERACTION_SHADOW_MAPPING_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"//#define _PBR\n"
"//#define _AMBIENT\n"
"//#define _POINT_LIGHT\n"
"//#define _SPOT_LIGHT\n"
"//#define _PARALLEL_LIGHT\n"
"\n"
"//#define HALF_LAMBERT\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying vec4 var_TexLight;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"varying vec3 var_H;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"varying vec3 var_V;\n"
"#endif\n"
"#if defined(_PBR)\n"
"varying vec3 var_Normal;\n"
"#endif\n"
"\n"
"uniform vec4 u_diffuseColor;\n"
"uniform vec4 u_specularColor;\n"
"#if defined(_PBR)\n"
"uniform vec4 u_specularExponent;\n"
"#else\n"
"uniform float u_specularExponent;\n"
"#endif\n"
"\n"
"uniform sampler2D u_fragmentMap0;    /* u_bumpTexture */\n"
"uniform sampler2D u_fragmentMap1;    /* u_lightFalloffTexture */\n"
"uniform sampler2D u_fragmentMap2;    /* u_lightProjectionTexture */\n"
"uniform sampler2D u_fragmentMap3;    /* u_diffuseTexture */\n"
"#if defined(_AMBIENT)\n"
"uniform samplerCube u_fragmentCubeMap4;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"#else\n"
"uniform sampler2D u_fragmentMap4;    /* u_specularTexture */\n"
"uniform sampler2D u_fragmentMap5;    /* u_specularFalloffTexture */\n"
"#endif\n"
"#ifdef _POINT_LIGHT\n"
"uniform highp samplerCube u_fragmentCubeMap6;    /* u_shadowMapCubeTexture */\n"
"#else\n"
"uniform highp sampler2D u_fragmentMap6;    /* u_shadowMapTexture */\n"
"#endif\n"
"uniform sampler2D u_fragmentMap7;    /* u_jitterMapTexture */\n"
"\n"
"uniform highp vec4 globalLightOrigin;\n"
"uniform mediump float u_uniformParm0; // shadow alpha\n"
"uniform highp vec4 u_uniformParm1; // (shadow map texture size, 1.0 / shadow map texture size, sampler factor, 0)\n"
"uniform highp vec4 u_uniformParm2; // (1.0 / screen width, 1.0 / screen height, jitter texture size, 1.0 / jitter texture size)\n"
"uniform highp float u_uniformParm4; // shadow bias for test\n"
"#define SHADOW_ALPHA u_uniformParm0\n"
"#define SHADOW_MAP_SIZE u_uniformParm1.x\n"
"#define SHADOW_MAP_SIZE_MULTIPLICATOR u_uniformParm1.y\n"
"#define JITTER_SCALE u_uniformParm1.z\n"
"#define SCREEN_SIZE_MULTIPLICATOR u_uniformParm2.xy\n"
"#ifdef _POINT_LIGHT\n"
"    varying highp vec3 var_LightToVertex;\n"
"    varying highp vec4 var_VertexPosition;\n"
"    uniform highp mat4 shadowMVPMatrix[6];\n"
"bool plane_ray_intersect(highp vec3 plane_point, highp vec3 plane_normal, highp vec3 dir, out highp vec3 ret) {\n"
"	highp float dotProduct = dot(dir, plane_normal);\n"
"	highp float dotProductFactor = 1.0 / dotProduct;\n"
"	// if(dotProduct == 0.0) return false;\n"
"	highp float l2 = dot(plane_normal, plane_point) * dotProductFactor;\n"
"	// if (l2 < 0.0) return false;\n"
"	highp float distance = dot(plane_normal, plane_point);\n"
"	highp float t = - (dot(plane_normal, dir) - distance) * dotProductFactor;\n"
"	ret = dir * t;\n"
"	return true;\n"
"}\n"
"#else\n"
"    varying highp vec4 var_ShadowCoord;\n"
"#endif\n"
"\n"
"#if !defined(_USING_DEPTH_TEXTURE) && defined(_PACK_FLOAT)\n"
UNPACK_FLOAT_FUNC()
"#define DC(x) (unpack(x))\n"
"#else\n"
"#define DC(x) ((x).r)\n"
"#endif\n"
"\n"
"#ifdef _DYNAMIC_BIAS\n"
"   #ifdef _PARALLEL_LIGHT\n"
"       #define BIAS_SCALE 0.999991\n"
"   #else\n"
"       #define BIAS_SCALE 0.999\n"
"   #endif\n"
"   #define BIAS(x) ((x) * BIAS_SCALE)\n"
"#elif defined(_FIXED_BIAS)\n"
"    #define BIAS_OFFSET 0.001\n"
"   #define BIAS(x) ((x) - BIAS_OFFSET)\n"
"#else\n"
"   #define BIAS(x) (x)\n"
"#endif\n"
"\n"
"#if defined(_PBR)\n"
_PBR_GENERAL_FUNCTION
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    //float u_specularExponent = 4.0;\n"
"\n"
"    vec3 L = normalize(var_L);\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"    vec3 H = normalize(var_H);\n"
"#endif\n"
"#if defined(BLINN_PHONG) || defined(_AMBIENT)\n"
"    vec3 N = 2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"    vec3 V = normalize(var_V);\n"
"    vec3 N = normalize(2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0);\n"
"#endif\n"
"\n"
"#if defined(_AMBIENT)\n"
"    vec3 globalNormal = var_TangentToWorldMatrix * N; // transform into ambient map space\n"
"    vec3 ambientValue = textureCube(u_fragmentCubeMap4, globalNormal).rgb; // load the ambient value\n"
"#endif\n"
"\n"
"    float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
"#if defined(HALF_LAMBERT)\n"
"    NdotL *= 0.5;\n"
"    NdotL += 0.5;\n"
"    NdotL = NdotL * NdotL;\n"
"#endif\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
"#endif\n"
"\n"
"    vec3 lightProjection = texture2DProj(u_fragmentMap2, var_TexLight.xyw).rgb;\n"
"    vec3 lightFalloff = texture2D(u_fragmentMap1, vec2(var_TexLight.z, 0.5)).rgb;\n"
"    vec3 diffuseColor = texture2D(u_fragmentMap3, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
"#if defined(_PBR)\n"
"    vec3 AN = normalize(mix(normalize(var_Normal), N, u_specularExponent.y));\n"
"    vec4 Cd = vec4(diffuseColor.rgb, 1.0);\n"
"    vec4 specTex = texture2D(u_fragmentMap4, var_TexSpecular);\n"
"    vec4 roughness = vec4(clamp(specTex.r * (sign(1.0 - abs(sign(u_specularExponent.z))) * 2.0 - 1.0) /* if max == 0, result = 1; else result = -1 */ + u_specularExponent.z, 0.0, 1.0)) * max(sign(specTex.r), 0.0) /* if specularTex.r == 0, result = 0, else result = 1 */; // roughness = max - specularTex.r, but if specularTex.r == 0, roughness = 0\n"
"    vec4 metallic = vec4(clamp(specTex.g + u_specularExponent.w, 0.0, 1.0)) * max(sign(specTex.g), 0.0) /* if specularTex.g == 0, result = 0, else result = 1 */; // metallic = specularTex.r, but if specularTex.r == 0, metallic = 0\n"
"\n"
"    vec4 Cl = vec4(lightProjection * lightFalloff, 1.0);\n"
"    vec3 F0 = vec3(0.04); \n"
"    F0 = mix(F0, Cd.xyz, metallic.xyz);\n"
"\n"
"    // cook-torrance brdf\n"
"    float NDF = DistributionGGX(AN, H, roughness.x);        \n"
"    float G   = GeometrySmith(AN, V, L, roughness.x);      \n"
"    vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //max       \n"
"\n"
"    vec3 kS = F;\n"
"    vec3 kD = vec3(1.0) - kS;\n"
"    kD *= 1.0 - metallic.r;\n"
"\n"
"    vec3 numerator    = NDF * G * F;\n"
"    float denominator = 4.0 * max(dot(AN, V), 0.0) * max(dot(AN, L), 0.0);\n"
"    vec3 pbr     = numerator / max(denominator, 0.001);  \n"
"\n"
"#if 1\n"
"    vec4 color = (Cd/* * vec4(kD, 1.0)*/ + (u_specularExponent.x * vec4(pbr.rgb, 0.0) * u_specularColor)) * NdotL * Cl;\n"
"    color = vec4(color.rgb, 1.0) * var_Color;\n"
"#else\n"
"    vec4 color = var_Color * Cl * NdotL * Cd + (u_specularExponent.x * vec4(pbr.rgb, 0.0) * (u_specularColor/* * Cl*/));\n"
"#endif\n"
"#elif defined(_AMBIENT)\n"
"    vec3 color = u_specularExponent * /*ambientValue * */diffuseColor * lightProjection * lightFalloff;\n"
"#else\n"
"    vec3 specularColor = 2.0 * texture2D(u_fragmentMap4, var_TexSpecular).rgb * u_specularColor.rgb;\n"
"\n"
"#if defined(BLINN_PHONG)\n"
"    float specularFalloff = pow(NdotH, u_specularExponent);\n"
"#else\n"
"    vec3 R = -reflect(L, N);\n"
"    float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
"    float specularFalloff = pow(RdotV, u_specularExponent);\n"
"#endif\n"
"#endif\n"
"\n"
"    highp float shadow = 0.0;\n"
"\n"
"#ifdef _POINT_LIGHT\n"
SHADOW_MAPPING_SAMPLE_CUBE_POISSON_DISK
"    highp vec3 toLightGlobal = normalize( -var_LightToVertex );\n"
"    int shadowIndex = 0;"
"    highp float axis[6];\n"
"    axis[0] = -toLightGlobal.x;\n"
"    axis[1] =  toLightGlobal.x;\n"
"    axis[2] = -toLightGlobal.y;\n"
"    axis[3] =  toLightGlobal.y;\n"
"    axis[4] = -toLightGlobal.z;\n"
"    axis[5] =  toLightGlobal.z;\n"
"    for( int i = 0; i < 6; ++i ) {\n"
"        //if( axis[i] > axis[shadowIndex] ) {        shadowIndex = i;    }\n"
"        shadowIndex = axis[i] > axis[shadowIndex] ? i : shadowIndex;\n"
"    }\n"
"    highp vec3 plane_normal;\n"
"    highp vec3 plane_point;\n"
"    highp float radius = SHADOW_MAP_SIZE * 0.5;\n"
"    if(shadowIndex == 0) { // +X \n"
"        plane_point = vec3(radius, 0.0, 0.0);\n"
"        plane_normal = vec3(-1.0, 0.0, 0.0);\n"
"    } else if(shadowIndex == 1) { // -X \n"
"        plane_point = vec3(-radius, 0.0, 0.0);\n"
"        plane_normal = vec3(1.0, 0.0, 0.0);\n"
"    } else if(shadowIndex == 2) { // +Y \n"
"        plane_point = vec3(0.0, radius, 0.0);\n"
"        plane_normal = vec3(0.0, -1.0, 0.0);\n"
"    } else if(shadowIndex == 3) { // -Y \n"
"        plane_point = vec3(0.0, -radius, 0.0);\n"
"        plane_normal = vec3(0.0, 1.0, 0.0);\n"
"    } else if(shadowIndex == 4) { // +Z \n"
"        plane_point = vec3(0.0, 0.0, radius);\n"
"        plane_normal = vec3(0.0, 0.0, -1.0);\n"
"    } else { // -Z \n"
"        plane_point = vec3(0.0, 0.0, -radius);\n"
"        plane_normal = vec3(0.0, 0.0, 1.0);\n"
"    }\n"
"    highp vec3 texcoordCube;\n"
"    plane_ray_intersect(plane_point, plane_normal, normalize(var_LightToVertex), texcoordCube);\n"
"    highp vec4 shadowPosition = var_VertexPosition * shadowMVPMatrix[shadowIndex];\n"
"    shadowPosition.xyz /= shadowPosition.w;\n"
"    highp float currentDepth = BIAS(shadowPosition.z);\n"
"    highp float distance = JITTER_SCALE * 0.5;\n"
"    for (int i = 0; i < SAMPLES; ++i) {\n"
"        highp vec3 jitter = sampleOffsetTable[i];\n"
"        highp float shadowDepth = DC(textureCube(u_fragmentCubeMap6, normalize(texcoordCube + jitter * distance)));\n"
"        highp float visibility = currentDepth - shadowDepth;\n"
"        shadow += 1.0 - step(0.0, visibility) * SHADOW_ALPHA;\n"
"        //shadow += visibility < 0.0 ? 1.0 : SHADOW_ALPHA;\n"
"    }\n"
"#else // end point light\n"
SHADOW_MAPPING_SAMPLE_POISSON_DISK
"    // highp float random = (gl_FragCoord.z + shadowPosition.z) * 0.5;\n"
"    highp float random = texture2D( u_fragmentMap7, gl_FragCoord.xy * SCREEN_SIZE_MULTIPLICATOR ).r;\n"
"    random *= 3.141592653589793;\n"
"    highp vec2 rot;\n"
"    rot.x = cos( random );\n"
"    rot.y = sin( random );\n"
"    highp float distance = JITTER_SCALE * SHADOW_MAP_SIZE_MULTIPLICATOR;\n"
"    highp vec3 shadowCoord = var_ShadowCoord.xyz / var_ShadowCoord.w;\n"
"    highp float currentDepth = BIAS(shadowCoord.z);\n"
"    for (int i = 0; i < SAMPLES; ++i) {\n"
"        highp vec2 jitter = sampleOffsetTable[i];\n"
"        highp vec2 jitterRotated;\n"
"        jitterRotated.x = jitter.x * rot.x - jitter.y * rot.y;\n"
"        jitterRotated.y = jitter.x * rot.y + jitter.y * rot.x;\n"
"        highp float shadowDepth = DC(texture2D(u_fragmentMap6, shadowCoord.st + jitterRotated * distance));\n"
"        highp float visibility = currentDepth - shadowDepth;\n"
"        shadow += 1.0 - step(0.0, visibility) * SHADOW_ALPHA;\n"
"        //shadow += visibility < 0.0 ? 1.0 : SHADOW_ALPHA;\n"
"    }\n"
"#endif\n"
"    const highp float sampleAvg = SAMPLE_MULTIPLICATOR;\n"
"    shadow *= sampleAvg;\n"
"\n"
"#if defined(_PBR)\n"
"    gl_FragColor = vec4(color.rgb * shadow, color.a);\n"
"#elif defined(_AMBIENT)\n"
"    color *= shadow;\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"#else\n"
"    vec3 color;\n"
"    color = diffuseColor;\n"
"    color += specularFalloff * specularColor;\n"
"    color *= NdotL * lightProjection;\n"
"    color *= lightFalloff;\n"
"    color *= shadow;\n"
"\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"#endif\n"
"}\n"
;

// z-fill perforated depth
GLSL_SHADER const char DEPTH_PERFORATED_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"uniform mat4 u_textureMatrix;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"\n"
"void main(void)\n"
"{\n"
"    var_TexDiffuse = (u_textureMatrix * attr_TexCoord).xy;\n"
"\n"
"    gl_Position = attr_Vertex * u_modelViewProjectionMatrix;\n"
"}\n"
;
GLSL_SHADER const char DEPTH_PERFORATED_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"//#define _USING_DEPTH_TEXTURE\n"
"//#define _PACK_FLOAT\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform lowp float u_alphaTest;\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"\n"
"#ifdef _PACK_FLOAT\n"
PACK_FLOAT_FUNC()
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    if (u_alphaTest > texture2D(u_fragmentMap0, var_TexDiffuse).a) {\n"
"        discard;\n"
"    }\n"
"\n"
"#ifdef _USING_DEPTH_TEXTURE\n"
"   #ifdef _DEBUG\n"
"       gl_FragColor = vec4((gl_FragCoord.z + 1.0) * 0.5, 0.0, 0.0, 1.0); // DEBUG\n"
"   #endif\n"
"#else\n"
"    highp float depth;\n"
"    depth = gl_FragCoord.z;\n"
"   #ifdef _PACK_FLOAT\n"
"        gl_FragColor = pack(depth);\n"
"   #else\n"
"        gl_FragColor = vec4(depth, 0.0, 0.0, 1.0);\n"
"   #endif\n"
"#endif\n"
"}\n"
;

#endif

#ifdef _STENCIL_SHADOW_IMPROVE
// interaction(stencil shadow augmented)
GLSL_SHADER const char INTERACTION_STENCIL_SHADOW_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"//#define _PBR\n"
"//#define _AMBIENT\n"
"//#define _TRANSLUCENT\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying vec4 var_TexLight;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"varying vec3 var_H;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"varying vec3 var_V;\n"
"#endif\n"
"#if defined(_PBR)\n"
"varying vec3 var_Normal;\n"
"#endif\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"attribute vec3 attr_Normal;\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"\n"
"uniform vec4 u_lightProjectionS;\n"
"uniform vec4 u_lightProjectionT;\n"
"uniform vec4 u_lightFalloff;\n"
"uniform vec4 u_lightProjectionQ;\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"uniform lowp vec4 u_glColor;\n"
"\n"
"uniform vec4 u_lightOrigin;\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"uniform vec4 u_bumpMatrixS;\n"
"uniform vec4 u_bumpMatrixT;\n"
"uniform vec4 u_diffuseMatrixS;\n"
"uniform vec4 u_diffuseMatrixT;\n"
"uniform vec4 u_specularMatrixS;\n"
"uniform vec4 u_specularMatrixT;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"#if defined(_AMBIENT)\n"
"uniform highp mat4 u_modelMatrix;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
"\n"
"    var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
"    var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
"    var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
"    var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexLight.x = dot(u_lightProjectionS, attr_Vertex);\n"
"    var_TexLight.y = dot(u_lightProjectionT, attr_Vertex);\n"
"    var_TexLight.z = dot(u_lightFalloff, attr_Vertex);\n"
"    var_TexLight.w = dot(u_lightProjectionQ, attr_Vertex);\n"
"\n"
"#if defined(_AMBIENT)\n"
"    vec3 L = normalize(vec3(0.0, 0.5, 1.0));\n"
"    var_TangentToWorldMatrix = mat3(u_modelMatrix) * M;\n"
"#else\n"
"    vec3 L = u_lightOrigin.xyz - attr_Vertex.xyz;\n"
"#endif\n"
"    vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"    vec3 H = normalize(L) + normalize(V);\n"
"#endif\n"
"\n"
"    var_L = L * M;\n"
"#if defined(BLINN_PHONG) || defined(_PBR) || defined(_AMBIENT)\n"
"    var_H = H * M;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"    var_V = V * M;\n"
"#endif\n"
"#if defined(_PBR)\n"
"    var_Normal = attr_Normal * M;\n"
"#endif\n"
"\n"
"    var_Color = " BYTE_COLOR(attr_Color) " * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;
GLSL_SHADER const char INTERACTION_STENCIL_SHADOW_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision highp float;\n"
"\n"
"//#define BLINN_PHONG\n"
"//#define _PBR\n"
"//#define _AMBIENT\n"
"//#define _TRANSLUCENT\n"
"//#define _SOFT\n"
"\n"
"//#define HALF_LAMBERT\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying vec4 var_TexLight;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"varying vec3 var_H;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"varying vec3 var_V;\n"
"#endif\n"
"#if defined(_PBR)\n"
"varying vec3 var_Normal;\n"
"#endif\n"
"\n"
"uniform vec4 u_diffuseColor;\n"
"uniform vec4 u_specularColor;\n"
"#if defined(_PBR)\n"
"uniform vec4 u_specularExponent;\n"
"#else\n"
"uniform float u_specularExponent;\n"
"#endif\n"
"\n"
"uniform sampler2D u_fragmentMap0;    /* u_bumpTexture */\n"
"uniform sampler2D u_fragmentMap1;    /* u_lightFalloffTexture */\n"
"uniform sampler2D u_fragmentMap2;    /* u_lightProjectionTexture */\n"
"uniform sampler2D u_fragmentMap3;    /* u_diffuseTexture */\n"
"#if defined(_AMBIENT)\n"
"uniform samplerCube u_fragmentCubeMap4;\n"
"varying mat3 var_TangentToWorldMatrix;\n"
"#else\n"
"uniform sampler2D u_fragmentMap4;    /* u_specularTexture */\n"
"uniform sampler2D u_fragmentMap5;    /* u_specularFalloffTexture */\n"
"#endif\n"
"uniform lowp float u_uniformParm0; // shadow alpha\n"
"\n"
"#if defined(_PBR)\n"
_PBR_GENERAL_FUNCTION
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    //float u_specularExponent = 4.0;\n"
"\n"
"    vec3 L = normalize(var_L);\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"    vec3 H = normalize(var_H);\n"
"#endif\n"
"#if defined(BLINN_PHONG) || defined(_AMBIENT)\n"
"    vec3 N = 2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
"#endif\n"
"#if (!defined(BLINN_PHONG) && !defined(_AMBIENT)) || defined(_PBR)\n"
"    vec3 V = normalize(var_V);\n"
"    vec3 N = normalize(2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0);\n"
"#endif\n"
"\n"
"#if defined(_AMBIENT)\n"
"    vec3 globalNormal = var_TangentToWorldMatrix * N; // transform into ambient map space\n"
"    vec3 ambientValue = textureCube(u_fragmentCubeMap4, globalNormal).rgb; // load the ambient value\n"
"#endif\n"
"\n"
"    float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
"#if defined(HALF_LAMBERT)\n"
"    NdotL *= 0.5;\n"
"    NdotL += 0.5;\n"
"    NdotL = NdotL * NdotL;\n"
"#endif\n"
"#if defined(BLINN_PHONG) || defined(_PBR)\n"
"    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
"#endif\n"
"\n"
"    vec3 lightProjection = texture2DProj(u_fragmentMap2, var_TexLight.xyw).rgb;\n"
"    vec3 lightFalloff = texture2D(u_fragmentMap1, vec2(var_TexLight.z, 0.5)).rgb;\n"
"    vec3 diffuseColor = texture2D(u_fragmentMap3, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
"#if defined(_PBR)\n"
"    vec3 AN = normalize(mix(normalize(var_Normal), N, u_specularExponent.y));\n"
"    vec4 Cd = vec4(diffuseColor.rgb, 1.0);\n"
"    vec4 specTex = texture2D(u_fragmentMap4, var_TexSpecular);\n"
"    vec4 roughness = vec4(clamp(specTex.r * (sign(1.0 - abs(sign(u_specularExponent.z))) * 2.0 - 1.0) /* if max == 0, result = 1; else result = -1 */ + u_specularExponent.z, 0.0, 1.0)) * max(sign(specTex.r), 0.0) /* if specularTex.r == 0, result = 0, else result = 1 */; // roughness = max - specularTex.r, but if specularTex.r == 0, roughness = 0\n"
"    vec4 metallic = vec4(clamp(specTex.g + u_specularExponent.w, 0.0, 1.0)) * max(sign(specTex.g), 0.0) /* if specularTex.g == 0, result = 0, else result = 1 */; // metallic = specularTex.r, but if specularTex.r == 0, metallic = 0\n"
"\n"
"    vec4 Cl = vec4(lightProjection * lightFalloff, 1.0);\n"
"    vec3 F0 = vec3(0.04); \n"
"    F0 = mix(F0, Cd.xyz, metallic.xyz);\n"
"\n"
"    // cook-torrance brdf\n"
"    float NDF = DistributionGGX(AN, H, roughness.x);        \n"
"    float G   = GeometrySmith(AN, V, L, roughness.x);      \n"
"    vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); //max       \n"
"\n"
"    vec3 kS = F;\n"
"    vec3 kD = vec3(1.0) - kS;\n"
"    kD *= 1.0 - metallic.r;\n"
"\n"
"    vec3 numerator    = NDF * G * F;\n"
"    float denominator = 4.0 * max(dot(AN, V), 0.0) * max(dot(AN, L), 0.0);\n"
"    vec3 pbr     = numerator / max(denominator, 0.001);  \n"
"\n"
"#if 1\n"
"    vec4 color = (Cd/* * vec4(kD, 1.0)*/ + (u_specularExponent.x * vec4(pbr.rgb, 0.0) * u_specularColor)) * NdotL * Cl;\n"
"    color = vec4(color.rgb, 1.0) * var_Color;\n"
"#else\n"
"    vec4 color = var_Color * Cl * NdotL * Cd + (u_specularExponent.x * vec4(pbr.rgb, 0.0) * (u_specularColor/* * Cl*/));\n"
"#endif\n"
"#elif defined(_AMBIENT)\n"
"    vec3 color = u_specularExponent * /*ambientValue * */diffuseColor * lightProjection * lightFalloff;\n"
"#else\n"
"    vec3 specularColor = 2.0 * texture2D(u_fragmentMap4, var_TexSpecular).rgb * u_specularColor.rgb;\n"
"\n"
"#if defined(BLINN_PHONG)\n"
"    float specularFalloff = pow(NdotH, u_specularExponent);\n"
"#else\n"
"    vec3 R = -reflect(L, N);\n"
"    float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
"    float specularFalloff = pow(RdotV, u_specularExponent);\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(_PBR)\n"
"    gl_FragColor = color\n"
"#ifdef _TRANSLUCENT\n"
"         * u_uniformParm0\n"
"#endif // _TRANSLUCENT\n"
"        ;\n"
"#elif defined(_AMBIENT)\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color\n"
"#ifdef _TRANSLUCENT\n"
"         * u_uniformParm0\n"
"#endif // _TRANSLUCENT\n"
"        ;\n"
"#else\n"
"    vec3 color;\n"
"    color = diffuseColor;\n"
"    color += specularFalloff * specularColor;\n"
"    color *= NdotL * lightProjection;\n"
"    color *= lightFalloff;\n"
"\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color\n"
"#ifdef _TRANSLUCENT\n"
"         * u_uniformParm0\n"
"#endif // _TRANSLUCENT\n"
"        ;\n"
"#endif\n"
"}\n"
;
#endif

#ifdef _GLOBAL_ILLUMINATION
GLSL_SHADER const char GLOBAL_ILLUMINATION_VERT[] =
"#version 100\n"
"\n"
"//#pragma optimize(off)\n"
"\n"
"//#define _BFG\n"
"//#define BLINN_PHONG\n"
"//#define HALF_LAMBERT\n"
"\n"
"precision highp float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"attribute vec3 attr_Normal;\n"
"attribute highp vec4 attr_Vertex;\n"
"attribute lowp vec4 attr_Color;\n"
"\n"
"uniform lowp float u_colorModulate; // 0 or 1/255\n"
"uniform lowp float u_colorAdd; // 0 or 1\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform vec4 u_viewOrigin;\n"
"\n"
"uniform vec4 u_bumpMatrixS;\n"
"uniform vec4 u_bumpMatrixT;\n"
"uniform vec4 u_diffuseMatrixS;\n"
"uniform vec4 u_diffuseMatrixT;\n"
"uniform vec4 u_specularMatrixS;\n"
"uniform vec4 u_specularMatrixT;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"varying vec3 var_H;\n"
"#if !defined(_BFG) && !defined(BLINN_PHONG)\n"
"varying vec3 var_V;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"    mat3 M = mat3(attr_Tangent, attr_Bitangent, attr_Normal);\n"
"\n"
"    var_TexNormal.x = dot(u_bumpMatrixS, attr_TexCoord);\n"
"    var_TexNormal.y = dot(u_bumpMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexDiffuse.x = dot(u_diffuseMatrixS, attr_TexCoord);\n"
"    var_TexDiffuse.y = dot(u_diffuseMatrixT, attr_TexCoord);\n"
"\n"
"    var_TexSpecular.x = dot(u_specularMatrixS, attr_TexCoord);\n"
"    var_TexSpecular.y = dot(u_specularMatrixT, attr_TexCoord);\n"
"\n"
"    vec3 L = normalize(vec3(0.0, 0.5, 1.0));\n"
"    vec3 V = u_viewOrigin.xyz - attr_Vertex.xyz;\n"
"    vec3 H = normalize(L) + normalize(V);\n"
"\n"
"    var_L = L * M;\n"
"    var_H = H * M;\n"
"#if !defined(_BFG) && !defined(BLINN_PHONG)\n"
"    var_V = V * M;\n"
"#endif\n"
"\n"
"    var_Color = attr_Color * u_colorModulate + u_colorAdd;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;

GLSL_SHADER const char GLOBAL_ILLUMINATION_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"//#define _BFG\n"
"//#define BLINN_PHONG\n"
"//#define HALF_LAMBERT\n"
"\n"
"precision highp float;\n"
"\n"
"varying vec2 var_TexDiffuse;\n"
"varying vec2 var_TexNormal;\n"
"varying vec2 var_TexSpecular;\n"
"varying lowp vec4 var_Color;\n"
"varying vec3 var_L;\n"
"varying vec3 var_H;\n"
"#if !defined(_BFG) && !defined(BLINN_PHONG)\n"
"varying vec3 var_V;\n"
"#endif\n"
"\n"
"uniform vec4 u_diffuseColor;\n"
"uniform vec4 u_specularColor;\n"
"uniform float u_specularExponent;\n"
"\n"
"uniform sampler2D u_fragmentMap0;    /* u_bumpTexture */\n"
"uniform sampler2D u_fragmentMap1;    /* u_diffuseTexture */\n"
"uniform sampler2D u_fragmentMap2;    /* u_specularTexture */\n"
"\n"
"void main(void)\n"
"{\n"
"#ifdef _BFG\n"
"    vec4 bumpMap = texture2D(u_fragmentMap0, var_TexNormal.st);\n"
"    vec3 diffuseMap = texture2D(u_fragmentMap1, var_TexDiffuse.st).xyz;\n"
"    vec3 specMap = texture2D(u_fragmentMap2, var_TexSpecular.st).xyz;\n"
"\n"
"    float specularPower = 10.0;\n"
"    vec3 localNormal;\n"
"    localNormal.xy = bumpMap.wy - 0.5;\n"
"    localNormal.z = sqrt(abs(dot(localNormal.xy, localNormal.xy) - 0.25));\n"
"    localNormal = normalize(localNormal);\n"
"    float hDotN = dot(normalize(var_H), localNormal);\n"
"    float specularContribution = pow (abs(hDotN), specularPower);\n"
"\n"
"    vec3 diffuseColor = diffuseMap * (u_diffuseColor.rgb/* * 0.5*/);\n"
"    vec3 specularColor = specMap * specularContribution * u_specularColor.rgb;\n"
"\n"
"    vec3 lightVector = normalize(var_L);\n"
"    float halfLdotN = dot(localNormal, lightVector) * 0.5 + 0.5;\n"
"    halfLdotN *= halfLdotN;\n"
"    float lightColor = u_specularExponent;\n"
#if 0
"    float rim = 1.0 - clamp(hDotN, 0.0, 1.0);\n"
"    float rimPower = 8.0;\n"
"    float rimColor = 0.125 * 1.2 * lightColor * pow(rim, rimPower);\n"
"    vec3 color = (diffuseColor + specularColor) * halfLdotN * lightColor + rimColor;\n"
#endif
"    vec3 color = (diffuseColor + specularColor) * halfLdotN * lightColor;\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"\n"
"#else\n"
"\n"
"    vec3 L = normalize(var_L);\n"
"    vec3 H = normalize(var_H);\n"
"    vec3 N = 2.0 * texture2D(u_fragmentMap0, var_TexNormal.st).agb - 1.0;\n"
"    float NdotL = clamp(dot(N, L), 0.0, 1.0);\n"
"\n"
"#ifdef HALF_LAMBERT\n"
"    NdotL *= 0.5;\n"
"    NdotL += 0.5;\n"
"    NdotL = NdotL * NdotL;\n"
"#endif\n"
"    vec3 diffuseColor = texture2D(u_fragmentMap1, var_TexDiffuse).rgb * u_diffuseColor.rgb;\n"
"    vec3 specularColor = 2.0 * texture2D(u_fragmentMap2, var_TexSpecular).rgb * u_specularColor.rgb;\n"
"\n"
"#ifdef BLINN_PHONG\n"
"    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n"
"    float specularFalloff = pow(NdotH, 12.0);\n"
"#else\n"
"    vec3 V = normalize(var_V);\n"
"    N = normalize(N);\n"
"    vec3 R = -reflect(L, N);\n"
"    float RdotV = clamp(dot(R, V), 0.0, 1.0);\n"
"    float specularFalloff = pow(RdotV, 3.0);\n"
"#endif\n"
"\n"
"    vec3 color;\n"
"    color = diffuseColor;\n"
"    color += specularFalloff * specularColor;\n"
"    color *= NdotL * u_specularExponent;\n"
"\n"
"    gl_FragColor = vec4(color, 1.0) * var_Color;\n"
"#endif\n"
"}\n"
;

#endif
