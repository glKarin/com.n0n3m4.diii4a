
// retro postprocess 2D general vertex shader
GLSL_SHADER const char RETRO_POSTPROCESS_2D_VERT[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"attribute vec4 attr_TexCoord;\n"
"attribute highp vec4 attr_Vertex;\n"
"\n"
"varying vec2 var_TexCoord;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = attr_Vertex;\n"
"    gl_Position.y = -attr_Vertex.y;\n"
"\n"
"    var_TexCoord = attr_TexCoord.xy;\n"
"}\n"
;

#define _RETRO_POSTPROCESS_GENERAL_ARRAY \
"    ArrayDitherArray8x8[0] = 0;\n" \
"    ArrayDitherArray8x8[1] = 32;\n" \
"    ArrayDitherArray8x8[2] = 8;\n" \
"    ArrayDitherArray8x8[3] = 40;\n" \
"    ArrayDitherArray8x8[4] = 2;\n" \
"    ArrayDitherArray8x8[5] = 34;\n" \
"    ArrayDitherArray8x8[6] = 10;\n" \
"    ArrayDitherArray8x8[7] = 42;\n" \
"    ArrayDitherArray8x8[8] = 48;\n" \
"    ArrayDitherArray8x8[9] = 16;\n" \
"    ArrayDitherArray8x8[10] = 56;\n" \
"    ArrayDitherArray8x8[11] = 24;\n" \
"    ArrayDitherArray8x8[12] = 50;\n" \
"    ArrayDitherArray8x8[13] = 18;\n" \
"    ArrayDitherArray8x8[14] = 58;\n" \
"    ArrayDitherArray8x8[15] = 26;\n" \
"    ArrayDitherArray8x8[16] = 12;\n" \
"    ArrayDitherArray8x8[17] = 44;\n" \
"    ArrayDitherArray8x8[18] = 4;\n" \
"    ArrayDitherArray8x8[19] = 36;\n" \
"    ArrayDitherArray8x8[20] = 14;\n" \
"    ArrayDitherArray8x8[21] = 46;\n" \
"    ArrayDitherArray8x8[22] = 6;\n" \
"    ArrayDitherArray8x8[23] = 38;\n" \
"    ArrayDitherArray8x8[24] = 60;\n" \
"    ArrayDitherArray8x8[25] = 28;\n" \
"    ArrayDitherArray8x8[26] = 52;\n" \
"    ArrayDitherArray8x8[27] = 20;\n" \
"    ArrayDitherArray8x8[28] = 62;\n" \
"    ArrayDitherArray8x8[29] = 30;\n" \
"    ArrayDitherArray8x8[30] = 54;\n" \
"    ArrayDitherArray8x8[31] = 22;\n" \
"    ArrayDitherArray8x8[32] = 3;\n" \
"    ArrayDitherArray8x8[33] = 35;\n" \
"    ArrayDitherArray8x8[34] = 11;\n" \
"    ArrayDitherArray8x8[35] = 43;\n" \
"    ArrayDitherArray8x8[36] = 1;\n" \
"    ArrayDitherArray8x8[37] = 33;\n" \
"    ArrayDitherArray8x8[38] = 9;\n" \
"    ArrayDitherArray8x8[39] = 41;\n" \
"    ArrayDitherArray8x8[40] = 51;\n" \
"    ArrayDitherArray8x8[41] = 19;\n" \
"    ArrayDitherArray8x8[42] = 59;\n" \
"    ArrayDitherArray8x8[43] = 27;\n" \
"    ArrayDitherArray8x8[44] = 49;\n" \
"    ArrayDitherArray8x8[45] = 17;\n" \
"    ArrayDitherArray8x8[46] = 57;\n" \
"    ArrayDitherArray8x8[47] = 25;\n" \
"    ArrayDitherArray8x8[48] = 15;\n" \
"    ArrayDitherArray8x8[49] = 47;\n" \
"    ArrayDitherArray8x8[50] = 7;\n" \
"    ArrayDitherArray8x8[51] = 39;\n" \
"    ArrayDitherArray8x8[52] = 13;\n" \
"    ArrayDitherArray8x8[53] = 45;\n" \
"    ArrayDitherArray8x8[54] = 5;\n" \
"    ArrayDitherArray8x8[55] = 37;\n" \
"    ArrayDitherArray8x8[56] = 63;\n" \
"    ArrayDitherArray8x8[57] = 31;\n" \
"    ArrayDitherArray8x8[58] = 55;\n" \
"    ArrayDitherArray8x8[59] = 23;\n" \
"    ArrayDitherArray8x8[60] = 61;\n" \
"    ArrayDitherArray8x8[61] = 29;\n" \
"    ArrayDitherArray8x8[62] = 53;\n" \
"    ArrayDitherArray8x8[63] = 21;\n"

#define _RETRO_POSTPROCESS_GENERAL_FUNCTION \
"#define RGB(r, g, b) vec3(float(r)/255.0, float(g)/255.0, float(b)/255.0)\n" \
"\n" \
"// array/table version from http://www.anisopteragames.com/how-to-fix-color-banding-with-dithering/\n" \
"int ArrayDitherArray8x8[64];\n" \
"\n" \
"int glsl100_mod( int a, int b )\n" \
"{\n" \
"    return a - (a / b) * b;\n" \
"}\n" \
"\n" \
"float DitherArray8x8( vec2 pos )\n" \
"{\n" \
"/* 8x8 Bayer ordered dithering  */\n" \
"/* pattern.  Each input pixel   */\n" \
"/* is scaled to the 0..63 range */\n" \
"/* before looking in this table */\n" \
"/* to determine the action.     */\n" \
"\n" \
"    int stippleOffset = glsl100_mod( int( pos.y ), 8 ) * 8 + glsl100_mod( int( pos.x ), 8 );\n" \
"    int byte = ArrayDitherArray8x8[stippleOffset];\n" \
"    float stippleThreshold = float(byte) / 64.0f;\n" \
"    return stippleThreshold;\n" \
"}\n"

// 2bit retro postprocess
GLSL_SHADER const char RETRO_2BIT_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 4\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"vec3 Average( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += pal[i];\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"vec3 Deviation( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"    vec3 avg = Average( pal );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += abs( pal[i] - avg );\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
_RETRO_POSTPROCESS_GENERAL_ARRAY
"\n"
"    // CGA\n"
"    // https://lospec.com/palette-list/cga-mibend4\n"
"    vec3 palette[NUM_COLORS];\n"
"    palette[0] = RGB( 41, 31, 35 );\n"
"    palette[1] = RGB( 189, 80, 47 );\n"
"    palette[2] = RGB( 52, 209, 175 );\n"
"    palette[3] = RGB( 247, 236, 185 );\n"
"\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = Deviation( palette );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture2D( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    color.rgb += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from C64 color palette\n"
"    color = LinearSearch( color.rgb, palette );\n"
"\n"
"    gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// c64 retro postprocess
GLSL_SHADER const char RETRO_C64_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 16\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"vec3 Average( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += pal[i];\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"vec3 Deviation( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"    vec3 avg = Average( pal );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += abs( pal[i] - avg );\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
_RETRO_POSTPROCESS_GENERAL_ARRAY
"\n"
"    // gamma corrected version\n"
"    vec3 palette[NUM_COLORS];\n"
"    palette[0] = RGB( 0, 0, 0 ); // black\n"
"    palette[1] = RGB( 255, 255, 255 ); // white\n"
"    palette[2] = RGB( 104, 55,  43 ); // red\n"
"    palette[3] = RGB( 112, 164, 178 ); // cyan\n"
"    palette[4] = RGB( 111, 61,  134 ); // purple\n"
"    palette[5] = RGB( 88,  141, 67 ); // green\n"
"    palette[6] = RGB( 53,  40,  121 ); // blue\n"
"    palette[7] = RGB( 184, 199, 111 ); // yellow\n"
"    palette[8] = RGB( 111, 79,  37 ); // orange\n"
"    palette[9] = RGB( 67,  57,  0 ); // brown\n"
"    palette[10] = RGB( 154, 103, 89 ); // light red\n"
"    palette[11] = RGB( 68,  68,  68 ); // dark grey\n"
"    palette[12] = RGB( 108, 108, 108 ); // grey\n"
"    palette[13] = RGB( 154, 210, 132 ); // light green\n"
"    palette[14] = RGB( 108, 94,  181 ); // light blue\n"
"    palette[15] = RGB( 149, 149, 149 ); // light grey;\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = Deviation( palette );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture2D( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    //color.rgb += vec3( dither, dither, dither ) * quantizationPeriod;\n"
"    color.rgb += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from C64 color palette\n"
"    color = LinearSearch( color.rgb, palette );\n"
"\n"
"    //color = texture2D( u_fragmentMap0, uv ).rgb;\n"
"    gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// cpc retro postprocess
GLSL_SHADER const char RETRO_CPC_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 31 // original 27\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRendert\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"\n"
"vec3 Average( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += pal[i];\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"vec3 Deviation( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"    vec3 avg = Average( pal );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += abs( pal[i] - avg );\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
_RETRO_POSTPROCESS_GENERAL_ARRAY
"\n"
"    // https://lospec.com/palette-list/ruzzi-cpc\n"
"    vec3 palette[NUM_COLORS];\n"
"    palette[0] = RGB( 0, 0, 28 ); // dark blue\n"
"    palette[1] = RGB( 28, 0, 28 ); // dark magenta\n"
"    palette[2] = RGB( 33, 30, 32 );\n"
"    palette[3] = RGB( 85, 85, 104 );\n"
"\n"
"    palette[4] = RGB( 36, 14, 11 );\n"
"    palette[5] = RGB( 26, 34, 114 );\n"
"    palette[6] = RGB( 68, 118, 16 );\n"
"    palette[7] = RGB( 129, 16, 51 );\n"
"    palette[8] = RGB( 50, 131, 113 );\n"
"    palette[9] = RGB( 124, 36, 136 );\n"
"    palette[10] = RGB( 151, 122, 44 );\n"
"    palette[11] = RGB( 16, 55, 218 );\n"
"    palette[12] = RGB( 143, 136, 132 );\n"
"    palette[13] = RGB( 222, 18, 92 );\n"
"    palette[14] = RGB( 100, 222, 21 );\n"
"    palette[15] = RGB( 32, 144, 210 );\n"
"    palette[16] = RGB( 120, 58, 220 );\n"
"    palette[17] = RGB( 74, 228, 112 );\n"
"    palette[18] = RGB( 223, 39, 158 );\n"
"    palette[19] = RGB( 236, 126, 74 );\n"
"    palette[20] = RGB( 174, 228, 38 );\n"
"    palette[21] = RGB( 136, 151, 219 );\n"
"    palette[22] = RGB( 49, 234, 203 );\n"
"    palette[23] = RGB( 163, 236, 128 );\n"
"    palette[24] = RGB( 238, 142, 151 );\n"
"    palette[25] = RGB( 224, 60, 223 );\n"
"    palette[26] = RGB( 249, 234, 56 );\n"
"    palette[27] = RGB( 152, 244, 218 );\n"
"    palette[28] = RGB( 239, 157, 228 );\n"
"    palette[29] = RGB( 252, 244, 144 );\n"
"    palette[30] = RGB( 255, 255, 233 );\n"
"\n"
"    const vec3 medianAbsoluteDeviation = RGB( 175, 6, 56 );\n"
"    const vec3 deviation = RGB( 67, 70, 62 );\n"
"    \n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = Deviation( palette );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture2D( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    //color.rgb += vec3( dither, dither, dither ) * quantizationPeriod;\n"
"    color += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from CPC color palette\n"
"    color = LinearSearch( color, palette );\n"
"\n"
"    //color = texture2D( u_fragmentMap0, uv ).rgb;\n"
"    gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// genesis retro postprocess
GLSL_SHADER const char RETRO_GENESIS_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 64 // original 61\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
_RETRO_POSTPROCESS_GENERAL_ARRAY
"\n"
"    // + very good dithering variety at dark grey values\n"
"    // + does not leak too much color into grey values\n"
"    // + good saturation when colors are really needed\n"
"    // - a bit too strong visible dithering pattern\n"
"    // https://lospec.com/palette-list/famicube\n"
"    vec3 palette[NUM_COLORS];\n"
"    palette[0] = RGB( 0, 0, 0 );\n"
"    palette[1] = RGB( 21, 21, 21 );\n"
"    palette[2] = RGB( 35, 23, 18 );\n"
"    palette[3] = RGB( 23, 40, 8 );\n"
"    palette[4] = RGB( 13, 32, 48 );\n"
"    palette[5] = RGB( 33, 22, 64 );\n"
"    palette[6] = RGB( 0, 78, 0 );\n"
"    palette[7] = RGB( 79, 21, 7 );\n"
"    palette[8] = RGB( 52, 52, 52 );\n"
"    palette[9] = RGB( 92, 60, 13 );\n"
"    palette[10] = RGB( 0, 96, 75 );\n"
"    palette[11] = RGB( 55, 109, 3 );\n"
"    palette[12] = RGB( 0, 23, 125 );\n"
"    palette[13] = RGB( 0, 82, 128 );\n"
"    palette[14] = RGB( 65, 93, 102 );\n"
"    palette[15] = RGB( 135, 22, 70 );\n"
"    palette[16] = RGB( 130, 60, 61 );\n"
"    palette[17] = RGB( 19, 157, 8 );\n"
"    palette[18] = RGB( 90, 25, 145 );\n"
"    palette[19] = RGB( 61, 52, 165 );\n"
"    palette[20] = RGB( 173, 78, 26 );\n"
"    palette[21] = RGB( 32, 181, 98 );\n"
"    palette[22] = RGB( 106, 180, 23 );\n"
"    palette[23] = RGB( 147, 151, 23 );\n"
"    palette[24] = RGB( 174, 108, 55 );\n"
"    palette[25] = RGB( 123, 123, 123 );\n"
"    palette[26] = RGB( 2, 74, 202 );\n"
"    palette[27] = RGB( 10, 152, 172 );\n"
"    palette[28] = RGB( 106, 49, 202 );\n"
"    palette[29] = RGB( 88, 211, 50 );\n"
"    palette[30] = RGB( 224, 60, 40 );\n"
"    palette[31] = RGB( 207, 60, 113 );\n"
"    palette[32] = RGB( 163, 40, 179 );\n"
"    palette[33] = RGB( 204, 143, 21 );\n"
"    palette[34] = RGB( 140, 214, 18 );\n"
"    palette[35] = RGB( 113, 166, 161 );\n"
"    palette[36] = RGB( 218, 101, 94 );\n"
"    palette[37] = RGB( 98, 100, 220 );\n"
"    palette[38] = RGB( 182, 193, 33 );\n"
"    palette[39] = RGB( 197, 151, 130 );\n"
"    palette[40] = RGB( 10, 137, 255 );\n"
"    palette[41] = RGB( 246, 143, 55 );\n"
"    palette[42] = RGB( 168, 168, 168 );\n"
"    palette[43] = RGB( 225, 130, 137 );\n"
"    palette[44] = RGB( 37, 226, 205 );\n"
"    palette[45] = RGB( 91, 168, 255 );\n"
"    palette[46] = RGB( 255, 187, 49 );\n"
"    palette[47] = RGB( 190, 235, 113 );\n"
"    palette[48] = RGB( 204, 105, 228 );\n"
"    palette[49] = RGB( 166, 117, 254 );\n"
"    palette[50] = RGB( 155, 160, 239 );\n"
"    palette[51] = RGB( 245, 183, 132 );\n"
"    palette[52] = RGB( 255, 231, 55 );\n"
"    palette[53] = RGB( 255, 130, 206 );\n"
"    palette[54] = RGB( 226, 215, 181 );\n"
"    palette[55] = RGB( 213, 156, 252 );\n"
"    palette[56] = RGB( 152, 220, 255 );\n"
"    palette[57] = RGB( 215, 215, 215 );\n"
"    palette[58] = RGB( 189, 255, 202 );\n"
"    palette[59] = RGB( 238, 255, 169 );\n"
"    palette[60] = RGB( 226, 201, 255 );\n"
"    palette[61] = RGB( 255, 233, 197 );\n"
"    palette[62] = RGB( 254, 201, 237 );\n"
"    palette[63] = RGB( 255, 255, 255 );\n"
"\n"
"    const vec3 medianAbsoluteDeviation = RGB( 63, 175, 2 );\n"
"    const vec3 deviation = RGB( 76, 62, 75 );\n"
"\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = deviation;\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture2D( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    color.rgb += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from C64 color palette\n"
"    color = LinearSearch( color.rgb, palette );\n"
"\n"
"    //color = texture2D( u_fragmentMap0, uv ).rgb;\n"
"    gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// ps1 retro postprocess
GLSL_SHADER const char RETRO_PS1_FRAG[] =
"#version 100\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR                4.0\n"
"#define Dithering_QuantizationSteps        32.0 // 8.0 = 2 ^ 3 quantization bits\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"\n"
"varying vec2 var_TexCoord;\n"
"varying lowp vec4 var_Color;\n"
"\n"
"vec3 Quantize( vec3 color, vec3 period )\n"
"{\n"
"    return floor( color * Dithering_QuantizationSteps ) * ( 1.0 / ( Dithering_QuantizationSteps - 1.0 ) );\n"
"}\n"
"\n"
_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
_RETRO_POSTPROCESS_GENERAL_ARRAY
"\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    // most Sony Playstation 1 titles used 5 bit per RGB channel\n"
"    // 2^5 = 32\n"
"    // 32 * 32 * 32 = 32768 colors\n"
"\n"
"    const float quantizationSteps = Dithering_QuantizationSteps;\n"
"    vec3 quantizationPeriod = vec3( 1.0 / ( quantizationSteps - 1.0 ) );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture2D( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    // add Bayer 8x8 dithering\n"
"    vec2 uvDither = gl_FragCoord.xy / RESOLUTION_DIVISOR;\n"
"\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    color.rgb += vec3( dither, dither, dither ) * quantizationPeriod;\n"
"\n"
"    // PSX color quantization with 15-bit\n"
"    color = Quantize( color, quantizationPeriod );\n"
"\n"
"    //color = texture2D( u_fragmentMap0, uv ).rgb;\n"
"    gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;
